{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to WSO2 Siddhi\n\n\nCurrent version of Siddhi v4.0 is built with Java 8.\n\n\nFor all releases see https://github.com/wso2/siddhi/releases\n\n\nSiddhi CEP is a lightweight, easy-to-use Open Source Complex Event Processing Engine (CEP) released as a Java Library under Apache Software License v2.0. Siddhi CEP processes events which are generated by various event sources, analyses them and notifies appropriate complex events according to the user specified queries.\n\n\nThis project was initiated as a research project at University of Moratuwa, Sri Lanka, and now being improved by WSO2 Inc.\n\n\nFeatures Supported\n\n\n\n\nFilter\n\n\nMultiple filter conditions can be defined \n\n\nFilters can be applied before and/or after Window operations\n\n\n\n\n\n\nJoin\n\n\nSupports joining two streams into one based on a condition   \n\n\nMatch operation triggering can be configured (making \"left\" or \"right\" or both streams to trigger)\n\n\nSupports Left, Right \n Full Outer Joins and Inner Join\n\n\n\n\n\n\nAggregation\n\n\nBy default shipped with Avg, Sum , Min, Max, etc\n\n\nSupports Custom Aggregations via its pluggable architecture\n\n\n\n\n\n\nGroup by\n\n\nSupports Group by based on more than one attribute\n\n\nSupported for all type of queries\n\n\n\n\n\n\nHaving\n\n\nSupported for all type of queries\n\n\n\n\n\n\nWindow\n\n\nDefault implementations to Windows are: Time Window, Time Batch Window, Length Window, Unique Window, etc\n\n\nSupports Window operators via the pluggable architecture\n\n\n\n\n\n\nConditions and Expressions\n\n\nSupporting condition and expression evaluation\n\n\nConditions supported are: and, or, not, ==,!=, \n=, \n, \n=, \n, and arithmetic operations\n\n\nAttributes supported are: boolean, string, int, long, float, double, object\n\n\nExpressions can be implemented as extensions via Siddhi's pluggable architecture\n\n\n\n\n\n\nPattern processing\n\n\nIdentifies pattern occurrences within streams\n\n\nSupports \"every\" conditions\n\n\nCan temporally process any amount of events from streams with followed-by (-\n) operation\n\n\nCan process two stream at the same time via \"and\" and \"or\" conditions\n\n\nCan collect multiple number of events, with min and max limit, using \"count\" condition\n\n\n\n\n\n\nSequence processing\n\n\nIdentifies continuous sequence of events from streams\n\n\nCan process two stream at the same time using \"or\" conditions on streams \n\n\nSupports zero to many, one to many, and zero to one conditions\n\n\n\n\n\n\nEvent Tables\n\n\nSupport for using historical data in realtime processing\n\n\nCan process with the in-memory, RDBMS or Hazelcast(In-memory data grid) based data collection\n\n\n\n\n\n\nPartitions\n\n\nSupports query partitions based on key words and value ranges \n\n\nMultiple queries can be grouped within a partition\n\n\n\n\n\n\nScripting \n\n\nSupport JavaScript \n Scala Scripts within Siddhi Queries\n\n\n\n\n\n\nQuery Language\n\n\nSQL like query language \n\n\nImplemented on Antlr4\n\n\nSupports Query, Stream Definition and Query Plan compilation\n\n\n\n\n\n\n\n\nSystem Requirements\n\n\n\n\nMinimum memory - 500 MB (based on in-memory data stored for processing)\n\n\nProcessor      - Pentium 800MHz or equivalent at minimum\n\n\nJava SE Development Kit 1.8 or higher\n\n\nTo build Siddhi CEP from the Source distribution, it is necessary that you have\n   JDK 1.7 version or later and Maven 3.0.4 or later\n\n\n\n\nQuestions\n\n\n\n\nQuestions are welcomed \n we are happy to help you integrate Siddhi to your project :)\n\n\nPost your questions on http://stackoverflow.com/ tagging [\"siddhi\"] (http://stackoverflow.com/search?q=siddhi)\n\n\n\n\nHow to Contribute\n\n\n\n\nPlease report issues at [Siddhi JIRA] (https://wso2.org/jira/browse/SIDDHI)\n\n\nSend your bug fixes pull requests to [master branch] (https://github.com/wso2/carbon-event-processing/tree/master) \n\n\n\n\nContact us\n\n\nSiddhi developers can be contacted via the mailing lists:\n  * Carbon Developers List : dev@wso2.org\n  * Carbon Architecture List : architecture@wso2.org\n\n\nWe welcome your feedback and contribution.\n\n\nSiddhi CEP Team", 
            "title": "Welcome to WSO2 Siddhi"
        }, 
        {
            "location": "/#welcome-to-wso2-siddhi", 
            "text": "", 
            "title": "Welcome to WSO2 Siddhi"
        }, 
        {
            "location": "/#current-version-of-siddhi-v40-is-built-with-java-8", 
            "text": "For all releases see https://github.com/wso2/siddhi/releases  Siddhi CEP is a lightweight, easy-to-use Open Source Complex Event Processing Engine (CEP) released as a Java Library under Apache Software License v2.0. Siddhi CEP processes events which are generated by various event sources, analyses them and notifies appropriate complex events according to the user specified queries.  This project was initiated as a research project at University of Moratuwa, Sri Lanka, and now being improved by WSO2 Inc.", 
            "title": "Current version of Siddhi v4.0 is built with Java 8."
        }, 
        {
            "location": "/#features-supported", 
            "text": "Filter  Multiple filter conditions can be defined   Filters can be applied before and/or after Window operations    Join  Supports joining two streams into one based on a condition     Match operation triggering can be configured (making \"left\" or \"right\" or both streams to trigger)  Supports Left, Right   Full Outer Joins and Inner Join    Aggregation  By default shipped with Avg, Sum , Min, Max, etc  Supports Custom Aggregations via its pluggable architecture    Group by  Supports Group by based on more than one attribute  Supported for all type of queries    Having  Supported for all type of queries    Window  Default implementations to Windows are: Time Window, Time Batch Window, Length Window, Unique Window, etc  Supports Window operators via the pluggable architecture    Conditions and Expressions  Supporting condition and expression evaluation  Conditions supported are: and, or, not, ==,!=,  =,  ,  =,  , and arithmetic operations  Attributes supported are: boolean, string, int, long, float, double, object  Expressions can be implemented as extensions via Siddhi's pluggable architecture    Pattern processing  Identifies pattern occurrences within streams  Supports \"every\" conditions  Can temporally process any amount of events from streams with followed-by (- ) operation  Can process two stream at the same time via \"and\" and \"or\" conditions  Can collect multiple number of events, with min and max limit, using \"count\" condition    Sequence processing  Identifies continuous sequence of events from streams  Can process two stream at the same time using \"or\" conditions on streams   Supports zero to many, one to many, and zero to one conditions    Event Tables  Support for using historical data in realtime processing  Can process with the in-memory, RDBMS or Hazelcast(In-memory data grid) based data collection    Partitions  Supports query partitions based on key words and value ranges   Multiple queries can be grouped within a partition    Scripting   Support JavaScript   Scala Scripts within Siddhi Queries    Query Language  SQL like query language   Implemented on Antlr4  Supports Query, Stream Definition and Query Plan compilation", 
            "title": "Features Supported"
        }, 
        {
            "location": "/#system-requirements", 
            "text": "Minimum memory - 500 MB (based on in-memory data stored for processing)  Processor      - Pentium 800MHz or equivalent at minimum  Java SE Development Kit 1.8 or higher  To build Siddhi CEP from the Source distribution, it is necessary that you have\n   JDK 1.7 version or later and Maven 3.0.4 or later", 
            "title": "System Requirements"
        }, 
        {
            "location": "/#questions", 
            "text": "Questions are welcomed   we are happy to help you integrate Siddhi to your project :)  Post your questions on http://stackoverflow.com/ tagging [\"siddhi\"] (http://stackoverflow.com/search?q=siddhi)", 
            "title": "Questions"
        }, 
        {
            "location": "/#how-to-contribute", 
            "text": "Please report issues at [Siddhi JIRA] (https://wso2.org/jira/browse/SIDDHI)  Send your bug fixes pull requests to [master branch] (https://github.com/wso2/carbon-event-processing/tree/master)", 
            "title": "How to Contribute"
        }, 
        {
            "location": "/#contact-us", 
            "text": "Siddhi developers can be contacted via the mailing lists:\n  * Carbon Developers List : dev@wso2.org\n  * Carbon Architecture List : architecture@wso2.org", 
            "title": "Contact us"
        }, 
        {
            "location": "/#we-welcome-your-feedback-and-contribution", 
            "text": "Siddhi CEP Team", 
            "title": "We welcome your feedback and contribution."
        }, 
        {
            "location": "/documentation/siddhi-quckstart-4.0/", 
            "text": "Siddhi Quick Start Guide\n\n\nWIP", 
            "title": "Quick Start Guide"
        }, 
        {
            "location": "/documentation/siddhi-quckstart-4.0/#siddhi-quick-start-guide", 
            "text": "WIP", 
            "title": "Siddhi Quick Start Guide"
        }, 
        {
            "location": "/documentation/siddhi-4.0/", 
            "text": "Siddhi Query Language Guide 4.0\n\n\nEvent streams\n\n\nThe event stream definition defines the event stream schema. An event stream definition contains a unique name and a \nset of attributes assigned specific types, with uniquely identifiable names within the stream.\n\n\nPurpose\n\nTo define the schema based on which events are selected to be processed in the execution plan to which the event stream\n is attached.\n\n\nSyntax\n\n\nThe following is the syntax of a query that defines a new event stream.\n\n\n`define stream \nstream name\n (\nattribute name\n \nattribute type\n, \nattribute name\n \nattribute type\n, ... );`\n\n\n\n\nThe following parameters are configured in an event stream definition.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstream name\n\n\nThe name of the event stream to be created.\n\n\n\n\n\n\nattribute name\n \nattribute type\n\n\nThe schema of an event stream is defined by adding the name and the type of each attribute as a value pair. \n \nattribute name\n: A unique name for the attribute. \n \n \nattribute type\n: The data type of the attribute value. This can be \nSTRING\n, \nINT\n, \nLONG\n, \nDOUBLE\n, \nFLOAT\n or \nBOOLEAN\n.\n\n\n\n\n\n\n\n\nExample\n\n\n`define stream TempStream (deviceID long, roomNo int, temp double);`\nThe above creates an event stream named TempStream with the following attributes.\n\n\n\n\n\n\ndeviceID\n of the \nlong\n attribute type\n\n\nroomNo\n of the \nint\n attribute type\n\n\ntemp\n of the \ndouble\n attribute type\n\n\n\n\nEvent sources\n\n\nEvent sinks\n\n\nFilters\n\n\nFilters are included in queries to filter information from input streams based on a specified condition.\n\n\nPurpose\n\nA filter allows you to separate events that match a specific condition as the output, or for further processing.\n\n\nSyntax\n\n\nFilter conditions should be defined in square brackets next to the input stream name as shown below.\n\n\nfrom \ninput stream name\n[\nfilter condition\n]select \nattribute name\n, \nattribute name\n, ...\ninsert into \noutput stream name\n\n\n\n\n\nThe following parameters are configured in a filter definition.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput stream name\n\n\nThe event stream from which events should be selected.\n\n\n\n\n\n\nfilter condition\n\n\nThe condition based on which the events should be filtered to be inserted into the output stream.\n\n\n\n\n\n\nattribute name\n\n\nThe specific attributes of which the values should be inserted into the output stream. Multiple\n\n\n\n\n\n\n\n\nattributes can be added as a list of comma-separated values.\n\n\n\n\n\n\noutput stream name\n\n\nThe event stream to which the filtered events should be inserted.\n\n\n\n\n\n\n\n\nExample\n\n\nThe following query filters all server rooms of which the temperature is greater than 40 degrees. The filtered events\nare taken from the \nTempStream\n input stream and inserted into the \nHighTempStream\n output stream.\n\n\nfrom TempStream [(roomNo \n= 100 and roomNo \n 110) and temp \n 40 ]select roomNo, temp\ninsert into HighTempStream;\n\n\n\n\nWindows\n\n\nWindows allow you to capture a subset of events based on a specific criterion from an input event stream for calculation. Each input stream can only have maximum of one window.\n\n\nPurpose\n\n\nTo create subsets of events within an event stream based on time or length. Event windows always operate as sliding windows.\n\n\ne.g., If you define a filter condition to find the maximum value out of every 10 events, you need to define a length window of 10 events. This window operates as a sliding window where the following 3 subsets can be identified in a list of 12 events received in a sequential order.\n\n\n\n\n\n\n\n\nSubset\n\n\nEvent Range\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1-10\n\n\n\n\n\n\n2\n\n\n2-11\n\n\n\n\n\n\n3\n\n\n3-12\n\n\n\n\n\n\n\n\nSyntax\n\n\nThe \n#window\n prefix should be inserted next to the relevant event stream in order to add a window.\n\n\nfrom \ninput stream name\n[\nfilter condition\n]#window.\nwindow name\n(\nparameter\n, \nparameter\n, ... )select \nattribute name\n, \nattribute name\n, ...\ninsert into \noutput stream name\n\n\n\n\n\nThe following parameters are configured in a window definition.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput stream name\n\n\nThe stream to which the window is applied.\n\n\n\n\n\n\nfilter condition\n\n\nThe filter condition based on which events are filtered from the defined window.\n\n\n\n\n\n\nwindow name\n\n\nThe name of the window. The name should include the following information:  \nThe type of the window. The supported inbuilt windows are listed in Inbuilt Windows.\n \nThe range of the window in terms of the time duration or the number of events.\n \ne.g, time(10 min) defines a time window of 10 minutes.\n\n\n\n\n\n\nparameter\n\n\n\n\n\n\n\n\nattribute name\n\n\nThe attributes of the events selected from the window that should be inserted into the output stream. Multiple attributes can be specified as a comma-separated list.\n\n\n\n\n\n\noutput stream name\n\n\n\n\n\n\n\n\n\n\nFor details on inbuilt windows supported for Siddhi, see Inbuilt Windows.\n   For details on how to manipulate window output based on event categories, see Output Event Categories.\n   For information on how to perform aggregate calculations within windows, see Aggregate Functions.\n\n\nAggregate functions\n\n\nAggregate functions perform aggregate calculations within defined windows.For the complete list of inbuilt aggregate\nfunctions supported see Inbuilt Aggregate Functions.\n\n\nSyntax\n\n\nfrom \ninput_stream\n#window.\nwindow_name\nselect \naggregate_function\n(\nattribute_name\n) as \nattribute_name\n, \nattribute1_name\n, \nattribute2_name\n, ...\ninsert \noutput_event_category\n into \noutput_stream\n;\n\n\n\n\nThe parameters configured are as follows:\n\n\nExample\n\nThe following query calculates the average for the temp attribute of the \nTempStream\n input stream within each time\nwindow of 10 minutes. Then it emits the events to the \nAvgTempStream\n output stream. Each event emitted to the output\nstream has the following.\n\n\n\n\navgTemp\n attribute with the average temperature calculated as the value.\n\n\nroomNo\n and deviceID attributes with their original values from the input stream.\n\n\n\n\nfrom TempStream#window.time(10 min)select avg(temp) as avgTemp, roomNo, deviceID\ninsert all events into AvgTempStream;\n\n\n\n\nAggregate function types\n\n\nThe following aggregate function types are supported\n\n\nGroup By\n\n\nGroup By\n allows you to group the aggregate based on specified attributes.\n\n\nSyntax\n\n\nfrom \ninput_stream\n#window.\nwindow_name\nselect \naggregate_function\n(\nattribute_name\n) as \nattribute_name\n, \nattribute1_name\n, \nattribute2_name\n, ...\ngroup by \nattribute_name\n, \nattribute1_name\n, \nattribute2_name\n, ...\ninsert into \noutput_stream\n;\n\n\n\n\nThe parameters configured are as follows.\n\n\nExample\n\nThe following query calculates the average temperature (\navgTemp\n) per room number (\nroomNo\n) within each sliding time\nwindow of 10 minutes (\n#window.time(10min)\n) in the \nTempStream\n input stream, and inserts the output into the\n\nAvgTempStream\n output stream.\n\n\n`\nbr\nfrom TempStream#window.time(10 min)select avg(temp) as avgTemp, roomNo, deviceID\n/br\n\n\nbr\ngroup by roomNo, deviceID\n/br\n\ninsert into AvgTempStream;`\n\n\n\n\nHaving\n\n\nHaving allows you to filter events after aggregation and after processing at the selector.\n\n\nSyntax\n\n\n`\nbr\nfrom \ninput_stream\n#window.\nwindow_name\nselect \naggregate_function\n(\nattribute_name\n) as \nattribute_name\n, \n\nattribute1_name\n, \nattribute2_name\n, ...\n/br\n\n\nbr\ngroup by \nattribute_name\n, \nattribute1_name\n, \nattribute2_name\n, ...\n/br\n\n\nbr\nhaving \ncondition\n/br\n\n insert into \noutput_stream\n;\n\n\n\n\nThe query parameters configured are as follows.\n\n\nExample\n\n\nThe following query calculates the average temperature for the last 10 minutes, and alerts if it exceeds 30 degrees.\n\n\n`\nbr\nfrom TempStream#window.time(10 min)select avg(temp) as avgTemp, roomNo\n/br\n\n\nbr\ngroup by roomNo\n/br\n\n\nbr\nhaving avgTemp \n 30\n/br\n\n insert into AlertStream;\n\n\n\n\nInbuilt aggregate functions\n\n\nAggregate functions are used to perform operations such as sum on aggregated set of events through a window. Usage of \nan aggregate function is as follows.\n\n\n@info(name = 'query1')\nfrom cseEventStream#window.timeBatch(1 sec)\nselect symbol, sum(price) as price\ninsert into resultStream;\n\n\n\n\nSum\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nlong|double\n sum(\nint|long|double|float\n arg)\n\n\n\n\n\n\nExtension Type\n\n\nAggregate Function\n\n\n\n\n\n\nDescription\n\n\nCalculates the sum for all the events.\n\n\n\n\n\n\nParameter\n\n\nThe value that needs to be summed.\n\n\n\n\n\n\nReturn Type\n\n\nReturns long if the input parameter type is \nint\n or \nlong\n, and returns double if the input parameter type is \nfloat\n or \ndouble\n.\n\n\n\n\n\n\nExamples\n\n\nsum(20)\n returns the sum of 20s as a long value for each event arrival and expiry.\n \nsum(temp)\n returns the sum of all temp attributes based on each event arrival and expiry.\n\n\n\n\n\n\n\n\nAverage\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\ndouble\n avg(\nint|long|double|float\n arg)\n\n\n\n\n\n\nExtension Type\n\n\nAggregate Function\n\n\n\n\n\n\nDescription\n\n\nCalculates the average for all the events.\n\n\n\n\n\n\nParameter\n\n\narg\n : The value that need to be averaged.\n\n\n\n\n\n\nReturn Type\n\n\nReturns the calculated average value as a double.\n\n\n\n\n\n\nExample\n\n\navg(temp)\n returns the average temp value for all the events based on their arrival and expiry.\n\n\n\n\n\n\n\n\nMaximum\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nint|long|double|float\n min(\nint|long|double|float\n arg)\n\n\n\n\n\n\nExtension Type\n\n\nAggregate Function\n\n\n\n\n\n\nDescription\n\n\nReturns the minimum value for all the events.\n\n\n\n\n\n\nParameter\n}\n\n\narg\n: The value that needs to be compared to find the minimum value.\n\n\n\n\n\n\nReturn Type\n\n\nReturns the minimum value in the same type as the input.\n\n\n\n\n\n\nExample\n\n\nmin(temp)\n returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\n\n\n\n\n\nMinimum\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nint|long|double|float\n min(\nint|long|double|float\n arg)\n\n\n\n\n\n\nExtension Type\n\n\nAggregate Function\n\n\n\n\n\n\nDescription\n\n\nReturns the minimum value for all the events.\n\n\n\n\n\n\nParameter\n\n\narg\n: The value that needs to be compared to find the minimum value.\n\n\n\n\n\n\nReturn Type\n\n\nReturns the minimum value in the same type as the input.\n\n\n\n\n\n\nExample\n\n\nmin(temp)\n returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\n\n\n\n\n\nCount\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nlong\n count()\n\n\n\n\n\n\nExtension Type\n\n\nAggregate Function\n\n\n\n\n\n\nDescription\n\n\nReturns the count of all the events.\n\n\n\n\n\n\nReturn Type\n\n\nReturns the event count as a long.\n\n\n\n\n\n\nExample\n\n\ncount()\n returns the count of all the events.\n\n\n\n\n\n\n\n\nStandard Deviation\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\ndouble\n stddev(\nint|long|double|float\n arg)\n\n\n\n\n\n\nExtension\n\n\nAggregate Function\n\n\n\n\n\n\nDescription\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\n\n\n\nParameter\n\n\narg\n:The value that should be used to calculate the standard deviation.\n\n\n\n\n\n\n\n\nDistinct Count\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nlong\n distinctcount(\nint|long|double|float|string\n arg)\n\n\n\n\n\n\nExtension\n\n\nAggregate Function\n\n\n\n\n\n\nDescription\n\n\nReturns the count of distinct occurrences for a given arg.\n\n\n\n\n\n\nParameter\n\n\narg\n: The value that should be counted.\n\n\n\n\n\n\nReturn Type\n\n\nReturns the count of distinct occurances for a given arg.\n\n\n\n\n\n\nExample\n\n\ndistinctcount(pageID)\n for the following output returns \n3\n.\n \n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\n\n\n\n\n\n\n\nForever Maximum\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nint|long|double|float\n maxForever (\nint|long|double|float\n arg)\n\n\n\n\n\n\nExtension\n\n\nAggregate Function\n\n\n\n\n\n\nDescription\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\n\n\n\nParameter\n\n\narg\n: The value that needs to be compared to find the maximum value.\n\n\n\n\n\n\nReturn Type\n\n\nReturns the maximum value in the same data type as the input.\n\n\n\n\n\n\nExample\n\n\nmaxForever(temp)\n returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\n\n\n\n\n\nForever Minimum\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nint|long|double|float\n minForever (\nint|long|double|float\n arg)\n\n\n\n\n\n\nExtension\n\n\nAggregate Function\n\n\n\n\n\n\nDescription\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\n\n\n\nParameter\n\n\narg\n: The value that needs to be compared to find the minimum value.\n\n\n\n\n\n\nReturn Type\n\n\nReturns the minimum value in the same data type as the input.\n\n\n\n\n\n\nExample\n\n\nminForever(temp)\n returns the minimum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\n\n\n\n\n\nInbuilt windows\n\n\nWSO2 Siddhi supports the following inbuilt windows.\n\n\ntime\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n time(\nint|long|time\n windowTime)\n\n\n\n\n\n\nExtension Type\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\n\n\n\nParameter\n\n\nwindowTime\n: The sliding time period for which the window should hold events.\n\n\n\n\n\n\nReturn Type\n\n\nReturns current and expired events.\n\n\n\n\n\n\nExamples\n\n\ntime(20)\n for processing events that arrived within the last 20 milliseconds.\ntime(2 min)\n for processing events that arrived within the last 2 minutes.\n\n\n\n\n\n\n\n\ntimeBatch\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n timeBatch(\nint|long|time\n windowTime, \nint\n startTime )\n\n\n\n\n\n\nExtension\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nA batch (tumbling) \ntime window\n that holds events that arrive during \nwindowTime\n periods, and gets updated for each \nwindowTime\n.\n\n\n\n\n\n\nParameters\n\n\nwindowTime\n: The batch time period for which the window should hold events.\n \nstartTime (Optional)\n: This specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n\n\n\n\n\nReturn Type\n\n\nReturns current and expired events.\n\n\n\n\n\n\nExamples\n\n\ntimeBatch(20)\n processes events that arrive every 20 milliseconds.\ntimeBatch(2 min)\n processes events that arrive every 2 minutes.\ntimeBatch(10 min, 0)\n processes events that arrive every 10 minutes starting from the 0th minute. e.g., If you deploy your window at 08:22 and the first event arrives at 08:26, this event occurs within the time window 08.20 - 08.30. Therefore, this event is emitted at 08.30.\n \ntimeBatch(10 min, 1000*60*5)\nprocesses events that arrive every 10 minutes starting from 5th minute. e.g., If you deploy your window at 08:22 and the first event arrives at 08:26, this event occurs within the time window 08.25 - 08.35. Therefore, this event is emitted at 08.35.\n\n\n\n\n\n\n\n\nlength\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n length(\nint\n windowLength)\n\n\n\n\n\n\nExtension Type\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nA sliding length window that holds the last \nwindowLength\n events at a given time, and gets updated for each arrival and expiry.\n\n\n\n\n\n\nParameter\n\n\nwindowLength\n: The number of events that should be included in a sliding length window.\n\n\n\n\n\n\nReturn Type\n\"\n\n\nReturns current and expired events.\n\n\n\n\n\n\nExamples\n\n\nlength(10)\n for processing the last 10 events.\nlength(200)\n for processing the last 200 events.\n\n\n\n\n\n\n\n\nlengthBatch\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n lengthBatch(\nint\n windowLength)\n\n\n\n\n\n\nExtension Type\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nA batch (tumbling) length window that holds a number of events specified as the \nwindowLength\n. The window is updated each time a batch of events that equals the number specified as the \nwindowLength\narrives.\n\n\n\n\n\n\nParameter\n\n\nwindowLength\n:The number of events the window should tumble.\n\n\n\n\n\n\nReturn Type\n\n\nReturns current and expired events.\n\n\n\n\n\n\nExamples\n\n\nlengthBatch(10)\n for processing 10 events as a batch.\nlengthBatch(200)\n for processing 200 events as a batch.\n\n\n\n\n\n\n\n\nexternalTime\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n externalTime(\nlong\n timestamp, \nint|long|time\n windowTime)\n\n\n\n\n\n\nExtension Type\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nA sliding time window based on external time. It holds events that arrived during the last \nwindowTime\n period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\n\n\n\nParameter\n\n\nwindowTime\n:The sliding time period for which the window should hold events.\n\n\n\n\n\n\nReturn Type\n\n\nReturns current and expired events.\n\n\n\n\n\n\nExamples\n\n\nexternalTime(eventTime,20)\n for processing events arrived within the last 20 milliseconds from the \neventTime\n.\nexternalTime(eventTimestamp, 2 min)\n for processing events arrived within the last 2 minutes from the \neventTimestamp\n.\n\n\n\n\n\n\n\n\ncron\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n cron(\nstring\n cronExpression)\n\n\n\n\n\n\nExtension Type\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\n\n\n\nParameter\n\n\ncronExpression\n: cron expression that represents a time schedule.\n\n\n\n\n\n\nReturn Type\n\n\nReturns current and expired events.\n\n\n\n\n\n\nExamples\n\n\ncron('*/5 * * * * ?')\n returns processed events as the output every 5 seconds.\n\n\n\n\n\n\n\n\nfirstUnique\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n firstUnique(\nstring\n attribute)\n\n\n\n\n\n\nExtension\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nFirst unique window processor keeps only the first events that are unique according to the given unique attribute.\n\n\n\n\n\n\nParameter\n:\nattribute\n: The attribute that should be checked for uniqueness.\n\n\n\n\n\n\n\n\nReturn Type\n\n\nReturns current and expired events.\n\n\n\n\n\n\nExamples\n\n\nfirstUnique(ip)\n returns the first event arriving for each unique ip.\n\n\n\n\n\n\n\n\nunique\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n  unique (\nstring\n  attribute )\n\n\n\n\n\n\nExtension\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nThis window keeps only the latest events that are unique according to the given unique attribute.\n\n\n\n\n\n\nParameter\n\n\nattribute\n: The attribute that should be checked for uniqueness.\n\n\n\n\n\n\nReturn Type\n\n\nReturns current and expired events.\n\n\n\n\n\n\nExample\n\n\nunique(ip)\n returns the latest event that arrives for each unique \nip\n.\n\n\n\n\n\n\n\n\nsort\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n sort(\nint\n windowLength)\nevent\n sort(\nint\n windowLength, \nstring\n attribute, \nstring\n order)\nevent\n sort(\nint\n windowLength, \nstring\n attribute, \nstring\n order, .. , \nstring\n attributeN, \nstring\n orderN)\n\n\n\n\n\n\nExtension\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\n\n\n\nParameter\n\n\nattribute\n: The attribute that should be checked for the order.\n\n\n\n\n\n\nReturn Type\n\n\nReturns current and expired events.\n\n\n\n\n\n\nExample\n\n\nsort(5, price, 'asc')\n keeps the events sorted by \nprice\n in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\n\n\n\n\n\nfrequent\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n frequent(\nint\n eventCount)\nevent\n frequent(\nint\n eventCount, \nstring\n attribute, .. , \nstring\n attributeN)\n\n\n\n\n\n\nExtension Type\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\n\n\n\nParameter\n\n\neventCount\n: The number of most frequent events to be emitted to the stream.\n\n\n\n\n\n\nReturn Type\n\n\nThe number of most frequent events to be emitted to the stream.\n\n\n\n\n\n\nExamples\n\n\nfrequent(2)\n returns the 2 most frequent events.\nfrequent(2, cardNo)\n returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\n\n\n\n\n\nlossyFrequent\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n lossyFrequent(\ndouble\n supportThreshold, \ndouble\n errorBound)\nevent\n lossyFrequent(\ndouble\n supportThreshold, \ndouble\n errorBound, \nstring\n attribute, .. , \nstring\n attributeN)\n\n\n\n\n\n\nExtension Type\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the \nsupportThreshold\n parameter.\n\n\n\n\n\n\nParameters\n\n\nerrorBound\n: The error bound value.\nattribute\n:The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n\n\n\n\n\nReturn Type\n\n\nReturns current and expired events.\n\n\n\n\n\n\nExamples\n\n\nlossyFrequent(0.1, 0.01)\n returns all the events of which the current frequency exceeds \n0.1\n, with an error bound of \n0.01\n.\n'lossyFrequent(0.3, 0.05, cardNo)\nreturns all the events of which the\ncardNo\nattributes frequency exceeds\n0.3\n, with an error bound of\n0.05`.\n\n\n\n\n\n\n\n\nexternalTimeBatch\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n externalTimeBatch(\nlong\n timestamp, \nint|long|time\n windowTime, \nint|long|time\n startTime, \nint|long|time\n timeout)\n\n\n\n\n\n\nExtension Type\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during \nwindowTime\n periods, and gets updated for every \nwindowTime\n.\n\n\n\n\n\n\nParameters\n\n\ntimestamp\n: The time that the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\nwindowTime\n: The batch time period for which the window should hold events.\nstartTime\n (Optional): User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as \nstartTime\n. When \nstartTime\n is not given, initial value of \ntimestamp\n is used as the default.\ntimeout\n(Optional): Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. If timeout is not provided, system waits till an event from next batch arrives to flush current batch.\n\n\n\n\n\n\nReturn Type\n\n\nReturns current and expired events.\n\n\n\n\n\n\nExamples\n\n\nexternalTimeBatch(eventTime,20)\n for processing events that arrive every 20 milliseconds from the \neventTime\n.\nexternalTimeBatch(eventTimestamp, 2 min)\n for processing events that arrive every 2 minutes from the \neventTimestamp\n.\nexternalTimeBatch(eventTimestamp, 2 sec, 0)\n for processing events that arrive every 2 seconds from the \neventTimestamp\n. This starts on 0th millisecond of an hour.\nexternalTimeBatch(eventTimestamp, 2 sec, eventTimestamp, 100)\n for processing events that arrive every 2 seconds from the \neventTimestamp\n. This considers the \neventTimeStamp\n of the first event as the start time, and waits 100 milliseconds for the arrival of a new event before flushing the current batch.\n\n\n\n\n\n\n\n\ntimeLength\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n timeLength ( \n int|long|time \n   windowTime,  \n int \n  windowLength )\n\n\n\n\n\n\nExtension Type\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nA sliding time window that, at a given time holds the last windowLength events that arrived during last windowTime period, and gets updated for every event arrival and expiry.\n\n\n\n\n\n\nParameters\n\n\nwindowTime\n: The sliding time period for which the window should hold events.\nwindowLength\n: The number of events that should be be included in a sliding length window.\n\n\n\n\n\n\nReturn Type\n\n\nReturns current and expired events.\n\n\n\n\n\n\nExamples\n\n\ntimeLength(20 sec, 10)\n for processing the last 10 events that arrived within the last 20 seconds.\ntimeLength(2 min, 5)\n for processing the last 5 events that arrived within the last 2 minutes.\n\n\n\n\n\n\n\n\nuniqueExternalTimeBatch\n\n\n\n\n\n\n\n\nDetail\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nevent\n uniqueExternalTimeBatch(\nstring\n attribute, \nlong\n timestamp, \nint|long|time\n windowTime, \nint|long|time\n startTime, \nint|long|time\n timeout, \nbool\n replaceTimestampWithBatchEndTime )\n\n\n\n\n\n\nExtension Type\n\n\nWindow\n\n\n\n\n\n\nDescription\n\n\nA batch (tumbling) time window based on external time that holds latest unique events that arrive during the \nwindowTime\n periods, and gets updated for each \nwindowTime\n.\n\n\n\n\n\n\nParameters\n\n\nattribute\n:The attribute that should be checked for uniqueness.\ntimestamp\n:The time considered as the current time for the window to act upon. The value of this parameter should be monotonically increasing.\nwindowTime\n:The batch time period for which the window should hold events.\nstartTime\n (Optional): The user-defined start time. This can either be a constant (of the \nint\n, \nlong\n or \ntime\n type) or an attribute of the corresponding stream (of the long type). If an attribute is provided, the initial value of this attribute is considered as the \nstartTime\n. When the \nstartTime\n is not given, the initial value of the timestamp is used by default.\ntimeout\n (Optional): The time duration to wait for the arrival of new event before flushing and giving output for events belonging to a specific batch. If the timeout is not provided, the system waits until an event from next batch arrives to flush the current batch.\nreplaceTimestampWithBatchEndTime\n (Optional): Replaces the value for the \ntimestamp\n parameter with the corresponding batch end time stamp.\n\n\n\n\n\n\nReturn Type\n\n\nReturns current and expired events.\n\n\n\n\n\n\nExamples\n\n\nuniqueExternalTimeBatch(ip, eventTime, 20)\n processes unique events based on the \nip\n attribute that arrives every 20 milliseconds from the  \neventTime\n.\nuniqueExternalTimeBatch(ip, eventTimestamp, 2 min)\n processes unique events based on the \nip\n attribute that arrives every 2 minutes from the \neventTimestamp\n.\nuniqueExternalTimeBatch(ip, eventTimestamp, 2 sec, 0)\n processes unique events based on the \nip\n attribute that arrives every 2 seconds from the \neventTimestamp\n. It starts on 0th millisecond of an hour.\nuniqueExternalTimeBatch(ip, eventTimestamp, 2 sec, eventTimestamp, 100)\n processes unique events based on the \nip\n attribute that arrives every 2 seconds from the \neventTimestamp\n. It considers the \neventTimestamp\n of the first event as the \nstartTime\n, and waits 100 milliseconds for the arrival of a new event before flushing current batch.\nuniqueExternalTimeBatch(ip, eventTimestamp, 2 sec, eventTimestamp, 100, true)\n processes unique events based on the ip attribute that arrives every 2 seconds from the \neventTimestamp\n. It considers the \neventTimestamp\n of the first event as \nstartTime\n, and waits 100 milliseconds for the arrival of a new event before flushing current batch. Here, the value for \neventTimestamp\n is replaced with the timestamp of the batch end.\n\n\n\n\n\n\n\n\nOutput event categories\n\n\nThe output of a window can be current events, expired events or both as specified. Following are the key words to be used to specify the event category that is emitted from a window.\n\n\n\n\n\n\n\n\nKey Word\n\n\nOutcome\n\n\n\n\n\n\n\n\n\n\ncurrent events\n\n\nThis emits all the events that arrive to the window. This is the default event category emitted when no particular category is specified.\n\n\n\n\n\n\nexpired events\n\n\nThis emits all the events that expire from the window.\n\n\n\n\n\n\nall events\n\n\nThis emits att the events that arrive to the window as well as all the events that expire from the window.\n\n\n\n\n\n\n\n\nSyntax\n\n\nfrom \ninput_stream\n#window.\nwindow_name\nselect *\ninsert \noutput_event_category\n into \noutput_stream\n\n\n\n\n\nExample\n\nThe following selects all the expired events of the \nTempStream\n input stream within a time window of 1 minute, and inserts them into the \nDelayedTempStream\n output stream.\n\n\nfrom TempStream#window.time(1 min)select *\ninsert expired events into DelayedTempStream\n\n\n\n\nOutput rate limiting\n\n\nOutput rate limiting allows queries to emit events periodically based on the condition specified.\n\n\nPurpose\n\n\nThis allows you to limit the output to what is required in order to avoid viewing unnecessary information.\n\n\nSyntax\n\n\nThe following is the syntax of an output rate limiting configuration.\n\n\nfrom \ninput stream name\n...select \nattribute name\n, \nattribute name\n, ...\noutput ({\noutput-type\n} every (\ntime interval\n|\nevent interval\n events) | snapshot every \ntime interval\n)\ninsert into \noutput stream name\n\n\n\n\n\nThe parameters configured for the output rate limiting are described in the following table.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noutput-time\n\n\nThis specifies which event(s) should be emitted as the output of the query. The possible values are as follows:\nfirst\n: Only the first event processed by the query in the specified time interval/sliding window is emitted.\nlast\n: Only the last event processed by the query in the specified time interval/sliding window is emitted.\nall\n: All the events processed by the query in the specified time interval/sliding window are emitted.\n\n\n\n\n\n\ntime interval\n\n\nThe time interval for the periodic event emission.\n\n\n\n\n\n\nevent interval\n\n\nThe number of events that defines the interval at which the emission of events take place. e.g., if the event interval is 10, the query emits a result for every 10 events.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\nEmitting events based on number of events\n\nHere the events are emitted every time the specified number of events arrive You can also specify whether to to emit only the first event, last event, or all events out of the events that arrived.\n\nIn this example, the last temperature per sensor is emitted for every 10 events.\n\n\n\n\nfrom TempStreamselect temp\ngroup by deviceID\noutput last every 10 events\ninsert into LowRateTempStream;\n\n\n\n\n\n\nEmitting events based on time\nHere, events are emitted for every predefined time interval. You can also specify whether to to emit only the first event, last event, or all events out of the events that arrived during the specified time interval.\n\n\n\n\nfrom TempStreamoutput every 10 sec\ninsert into LowRateTempStream;\n\n\n\n\n\n\nEmitting a periodic snapshot of events\n\nThis method works best with windows. When an input stream is connected to a window, snapshot rate limiting emits all the current events that have arrived and do not have corresponding expired events for every predefined time interval. If the input stream is not connected to a window, only the last current event for each predefined time interval is emitted.\n\nThe following emits a snapshot of the events in a time window of 5 seconds every 1 second. \n\n\n\n\nfrom TempStream#window.time(5 sec)output snapshot every 1 sec\ninsert into SnapshotTempStream;\n\n\n\n\nJoins\n\n\nJoin allows two event streams to be merged based on a condition. In order to carry out a join, each stream should be connected to a window. If no window is specified, a window of zero length (\n#window.length(0)\n) is assigned to the input event stream by default. During the joining process each incoming event on each stream is matched against all the events in the other input event stream window based on the given condition. An output event is generated for all the matching event pairs.\n\n\nSyntax\n\nThe syntax for a join is as follows:\n\n\nfrom \ninput stream name\n[\nfilter condition\n]#window.\nwindow name\n(\nparameter\n, ... ) {unidirectional} {as \nreference\n}\n         join \ninput stream name\n#window.\nwindow name\n(\nparameter\n,  ... ) {unidirectional} {as \nreference\n}\n    on \njoin condition\n\n    within \ntime gap\n\nselect \nattribute name\n, \nattribute name\n, ...\ninsert into \noutput stream name\n\n\n\n\n\nExample\n\n\ndefine stream TempStream(deviceID long, roomNo int, temp double);\ndefine stream RegulatorStream(deviceID long, roomNo int, isOn bool);\n\nfrom TempStream[temp \n 30.0]#window.time(1 min) as T\n  join RegulatorStream[isOn == false]#window.length(1) as R\n  on T.roomNo == R.roomNo\nselect T.roomNo, R.deviceID, 'start' as action\ninsert into RegulatorActionStream;\n\n\n\n\nWSO2 Siddhi currently supports the following types of joins.\n\n\nLeft Outer Join\n\n\nOuter join allows two event streams to be merged based on a condition. However, it returns all the events of left stream even if there are no matching events in the right stream. Here each stream should be associated with a window. During the joining process, each incoming event of each stream is matched against all the events in the other input event stream window based on the given condition. Incoming events of the right stream are matched against all events in the left event stream window based on the given condition. An output event is generated for all the matching event pairs. An output event is generated for incoming events of the left stream even if there are no matching events in right stream.\n\n\nExample\n\nThe following query generates output events for all the events in the \nstockStream\n stream whether there is a match for the symbol in the \ntwitterStream\n stream or not.\n\n\nfrom stockStream#window.length(2) \nleft outer join twitterStream#window.length(1)\non stockStream.symbol== twitterStream.symbol\nselect stockStream.symbol as symbol, twitterStream.tweet, stockStream.price\ninsert all events into outputStream ;\n\n\n\n\nRight Outer Join\n\n\nThis is similar to left outer join. It returns all the events of the right stream even if there are no matching events in the left stream. Incoming events of the left stream are matched against all events in the right event stream window based on the given condition. An output event is generated for all the matching event pairs. An output event is generated for incoming events of the right stream even if there are no matching events in left stream.\n\n\nExample\n\nThe following generates output events for all the events in the \ntwitterStream\n stream whether there is a match for the symbol in the \nstockStream\n stream or not.\n\n\nfrom stockStream#window.length(2) \nright outer join twitterStream#window.length(1)\non stockStream.symbol== twitterStream.symbol\nselect stockStream.symbol as symbol, twitterStream.tweet, stockStream.price\ninsert all events into outputStream ;\n\n\n\n\nFull Outer Join\n\n\nPatterns and Sequences\n\n\nPatterns and sequences allow event streams to be correlated over time and detect event patterns based on the order of event arrival.\n\n\nPatterns\n\n\nPattern allows event streams to be correlated over time and detect event patterns based on the order of event arrival. With pattern there can be other events in between the events that match the pattern condition. It creates state machines to track the states of the matching process internally. Pattern can correlate events over multiple input streams or over the same input stream. Therefore, each matched input event need to be referenced so that that it can be accessed for future processing and output generation.\n\n\nSyntax\n\nThe following is the syntax for a pattern configuration:\n\n\nfrom {every} \ninput event reference\n=\ninput stream name\n[\nfilter condition\n] -\n {every} \ninput event reference\n=\ninput stream name\n[\nfilter condition\n] -\n ...        within \ntime gap\n\nselect \ninput event reference\n.\nattribute name\n, \ninput event reference\n.\nattribute name\n, ...\ninsert into \noutput stream name\n\n\n\n\n\nExample\n\n\nThe following query sends an alert if the temperature of a room increases by 5 degrees within 10 min.\n\n\nfrom every( e1=TempStream ) -\n e2=TempStream[e1.roomNo==roomNo and (e1.temp + 5) \n= temp ]\n    within 10 min\nselect e1.roomNo, e1.temp as initialTemp, e2.temp as finalTemp\ninsert into AlertStream;\n\n\n\n\nWSO2 Siddhi supports the following types of patterns:\n+ Counting patterns\n+ Logical patterns\n\n\nCounting Patterns\n\n\nCounting patterns allow multiple events that may or may not have been received in a sequential order based on the same matching condition.\n\n\nSyntax\n\n\nThe number of events matched can be limited via postfixes as explained below.\n\n\n\n\n\n\n\n\nPostfix\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\n\nn1:n2\n\n\nThis matches \nn1\n to \nn2\n events.\n\n\n1:4\n matches 1 to 4 events.\n\n\n\n\n\n\n\n\nn:\n\n\nThis matches \nn\n or more events.\n\n\n2:\n matches 2 or more events.\n\n\n\n\n\n\n\n\n:n\n\n\nThis matches up to \nn\n events.\n\n\n:5\n matches up to 5 events.\n\n\n\n\n\n\n\n\nn\n\n\nThis matches exactly \nn\n events.\n\n\n5\n matches exactly 5 events.\n\n\n\n\n\n\n\n\n\n\nSpecific occurrences of the events that should be matched based on count limits are specified via key words and numeric values within square brackets as explained with the examples given below.\n\n\n\n\ne1[3]\n refers to the 3rd event.\n\n\ne1[last]\n refers to the last event.\n\n\ne1[last - 1]\n refers to the event before the last event.\n\n\n\n\nExample\n\nThe following query calculates the temperature difference between two regulator events.\n\n\ndefine stream TempStream(deviceID long, roomNo int, temp double);\ndefine stream RegulatorStream(deviceID long, roomNo int, tempSet double, isOn bool);\n\nfrom every( e1=RegulatorStream) -\n e2=TempStream[e1.roomNo==roomNo]\n1:\n -\n e3=RegulatorStream[e1.roomNo==roomNo]\nselect e1.roomNo, e2[0].temp - e2[last].temp as tempDiff\ninsert into TempDiffStream;\n\n\n\n\nLogical Patterns\n\n\nLogical pattern matches events that arrive in temporal order and correlates events with logical relationships.\n\n\nSyntax\n\n\nKeywords such as and and or can be used instead of -\n to illustrate the logical relationship.\n\n\n\n\n\n\n\n\nKey Word\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nand\n\n\nThis allows two events received in any order to be matched.\n\n\n\n\n\n\nor\n\n\nOne event from either event stream can be matched regardless of the order in which the events were received.\n\n\n\n\n\n\n\n\nExample\n\nThe following query sends an alert when the room temperature reaches the temperature set on the regulator. The pattern matching is reset every time the temperature set on the regulator changes.\n\n\ndefine stream TempStream(deviceID long, roomNo int, temp double);\ndefine stream RegulatorStream(deviceID long, roomNo int, tempSet double);\n\nfrom every( e1=RegulatorStream ) -\n e2=TempStream[e1.roomNo==roomNo and e1.tempSet \n= temp ] or e3=RegulatorStream[e1.roomNo==roomNo]\nselect e1.roomNo, e2.temp as roomTemp\nhaving e3 is null\ninsert into AlertStream;\n\n\n\n\nSequences\n\n\nSequence allows event streams to be correlated over time and detect event sequences based on the order of event arrival. With sequence there cannot be other events in between the events that match the sequence condition. It creates state machines to track the states of the matching process internally. Sequence can correlate events over multiple input streams or over the same input stream. Therefore, each matched input event needs to be referenced so that it can be accessed for future processing and output generation.\n\nSyntax\n\n\nThe following is the syntax for a sequence configuration.\n\n\nfrom {every} \ninput event reference\n=\ninput stream name\n[\nfilter condition\n], \ninput event reference\n=\ninput stream name\n[\nfilter condition\n]{+|*|?}, ...       within \ntime gap\n\nselect \ninput event reference\n.\nattribute name\n, \ninput event reference\n.\nattribute name\n, ...\ninsert into \noutput stream name\n\n\n\n\n\nExample\n\n\nThe following query sends an alert if there is more than 1 degree increase in the temperature between two consecutive temperature events.\n\n\nWSO2 Siddhi supports the following types of sequences:\n\n\n\n\nCounting sequences\n\n\nLogical sequences\n\n\n\n\nCounting sequences\n\n\nCounting sequence allows us to match multiple consecutive events based on the same matching condition.\n\n\nSyntax\n\n\nThe number of events matched can be limited via postfixes as explained below.\n\n\n\n\n\n\n\n\nPostfix\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nThis matches zero or more events.\n\n\n\n\n\n\n+\n\n\nThis matches 1 or more events.\n\n\n\n\n\n\n?\n\n\nThis matches zero events or one event.\n\n\n\n\n\n\n\n\nExample\n\n\nThe following query identifies peak temperatures.\n\n\ndefine stream TempStream(deviceID long, roomNo int, temp double);\ndefine stream RegulatorStream(deviceID long, roomNo int, tempSet double, isOn bool);\n\nfrom every e1=TempStream, e2=TempStream[e1.temp \n= temp]+, e3=TempStream[e2[last].temp \n temp]\nselect e1.temp as initialTemp, e2[last].temp as peakTemp\ninsert into TempDiffStream;\n\n\n\n\nLogical Sequences\n\n\nLogical sequence matches events that arrive in temporal order and correlates events with logical relationships.\n\n\nSyntax\n\n\nKeywords such as and and or can be used instead of -\n to illustrate the logical relationship.\n\n\n\n\n\n\n\n\nKeyword\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nand\n\n\nThis allows two events received in any order to be matched.\n\n\n\n\n\n\nor\n\n\nOne event from either event stream can be matched regardless of the order in which the events were received.\n\n\n\n\n\n\n\n\nExample\n\n\nThe following query creates a notification when a regulator event is followed by both temperature and humidity events.\n\n\ndefine stream TempStream(deviceID long, temp double);define stream HumidStream(deviceID long, humid double);\ndefine stream RegulatorStream(deviceID long, isOn bool);\n\nfrom every e1=RegulatorStream, e2=TempStream and e3=HumidStream\nselect e2.temp, e3.humid\ninsert into StateNotificationStream;\n\n\n\n\nPartitions\n\n\nPartitions allow events and queries to be divided in order to process them in parallel and in isolation. Each partition is tagged with a partition key. Only events corresponding to this key are processed for each partition. A partition can contain one or more Siddhi queries.\nSiddhi supports both variable partitions and well as range partitions.\n\n\nVariable Partitions\n\n\nA variable partition is created by defining the partition key using the categorical (string) attribute of the input event stream.\n\n\nSyntax\n\n\npartition with ( \nattribute name\n of \nstream name\n, \nattribute name\n of \nstream name\n, ... )begin\n    \nquery\n\n    \nquery\n\n    ...\nend;\n\n\n\n\nExample\n\n\nThe following query calculates the maximum temperature recorded for the last 10 events emitted per sensor.\n\n\npartition with ( deviceID of TempStream )begin\n    from TempStream#window.length(10)\n    select roomNo, deviceID, max(temp) as maxTemp\n    insert into DeviceTempStream\nend;\n\n\n\n\nRange Partitions\n\n\nA range partition is created by defining the partition key using the numerical attribute of the input event stream.\n\n\nSyntax\n\n\npartition with ( \ncondition\n as \npartition key\n or \ncondition\n as \npartition key\n or ... of \nstream name\n, ... )begin\n    \nquery\n\n    \nquery\n\n    ...\nend;\n\n\n\n\nExample\n\n\nThe following query calculates the average temperature for the last 10 minutes per office area.\n\n\npartition with ( roomNo\n=1030 as 'serverRoom' or roomNo\n1030 and roomNo\n=330 as 'officeRoom' or roomNo\n330 as 'lobby' of TempStream) )begin\n    from TempStream#window.time(10 min)\n    select roomNo, deviceID, avg(temp) as avgTemp\n    insert into AreaTempStream\nend;\n\n\n\n\nEvent Table\n\n\nAn event table is a stored version of an event stream or a table of events. It allows Siddhi to work with stored events. Events are stored in-memory by default, and Siddhi also provides an extension to work with data/events stored in RDBMS data stores.\n\n\nDefining An Event Table\n\n\nAn event table definition defines the table schema. The syntax for an event table definition is as follows.\n\n\ndefine table \ntable name\n (\nattribute name\n \nattribute type\n, \nattribute name\n \nattribute type\n, ... );\n\n\n\n\nExample\n\n\nThe following creates a table named \nRoomTypeTable\n with the attributes \nroomNo\n (an \nINT\n attribute) and \ntype\n (a \nSTRING\n attribute).\n\n\ndefine table RoomTypeTable (roomNo int, type string);\n\n\n\n\nEvent Table Types\n\n\nSiddhi supports the following types of event tables.\n\n\nIn-memory Event Table\n\n\nIn memory event tables are created to store events for later access. Event tables can be configured with primary keys to avoid the duplication of data, and indexes for fast event access.\nPrimary keys are configured by including the \n@PrimaryKey\n annotation within the event table configuration. Each event table can have only one attribute defined as the primary key, and the value for this attribute should be unique for each entry saved in the table. This ensures that entries in the table are not duplicated\nIndexes are configured by including the \n@Index\n annotation within the event table configuration. Each event table configuration can have only one \n@Index\n annotation. However, multiple attributes can be specified as index attributes via a single annotation. When the \n@Index\n annotation is defined, multiple entries can be stored for a given key in the table. Indexes can be configured together with primary keys. \n\n\nExamples\n\n\n\n\nConfiguring primary keys\nThe following query creates an event table with the \nsymbol\n attribute defined as the primary key. Therefore, each entry in this table should have a unique value for the \nsymbol\n attribute.\n\n\n\n\n@PrimaryKey('symbol')\ndefine table StockTable (symbol string, price float, volume long);\n\n\n\n\n\n\nConfiguring indexes\n\n\n\n\nThe following query creates an indexed event table named \nRoomTypeTable\n with the attributes \nroomNo\n (as an \nINT\n attribute) and \ntype\n (as a \nSTRIN\nG attribute). All entries in the table are to be indexed by the \nroomNo\n attribute.\n\n\n@Index('roomNo')\ndefine table RoomTypeTable (roomNo int, type string);\n\n\n\n\nHazlecast Event Table\n\n\nEvent tables allow event data to be persisted in a distributed manner using Hazelcast in-memory data grids. This functionality is enabled using the \nFrom\n annotation. Also, the connection instructions for the Hazelcast cluster can be provided with the \nFrom\n annotation.\nThe following is a list of connection instructions that can be provided with the \nFrom\n annotation.\n\n\n\n\ncluster.name : Hazelcast cluster/group name [Optional]  (i.e cluster.name='cluster_a')\n\n\ncluster.password : Hazelcast cluster/group password [Optional]  (i.e cluster.password='pass@cluster_a')\n\n\ncluster.addresses : Hazelcast cluster addresses (ip:port) as a comma separated string [Optional, client mode only] (i.e cluster.addresses='192.168.1.1:5700,192.168.1.2:5700')\n\n\nwell.known.addresses : Hazelcast WKAs (ip) as a comma separated string [Optional, server mode only] (i.e well.known.addresses='192.168.1.1,192.168.1.2')\n\n\ncollection.name : Hazelcast collection object name [Optional, can be used to share single table between multiple EPs] (i.e collection.name='stockTable')\n\n\n\n\nExamples\n\n\n\n\nCreating a table backed by a new Hazelcast instance\n\n\n\n\nThe following query creates an event table named \nRoomTypeTable\n with the attributes \nroomNo\n (an \nINT\n attribute) and \ntype\n (a \nSTRING\n attribute), backed by a \nnew\n Hazelcast Instance.\n\n\n@from(eventtable = 'hazelcast')\ndefine table RoomTypeTable(roomNo int, type string);\n\n\n\n\n\n\nCreating a table backed by a new Hazelcast instance in a new Hazelcast cluster\nThe following query creates an event table named \nRoomTypeTable\n with the attributes \nroomNo\n (an \nINT\n attribute) and \ntype\n (a \nSTRING\n attribute), backed by a \nnew\n Hazelcast Instance in a new Hazelcast cluster.\n\n\n\n\n@from(eventtable = 'hazelcast', cluster.name = 'cluster_a', cluster.password = 'pass@cluster_a')\ndefine table RoomTypeTable(roomNo int, type string);\n\n\n\n\n\n\nCreating a table backed by an existing Hazelcast instance in an existing Hazelcast cluster\nThe following query creates an event table named \nRoomTypeTable\n with the attributes \nroomNo\n (an \nINT\n attribute) and \ntype\n (a \nSTRING\n attribute), backed by an existing Hazelcast Instance in an existing Hazelcast Cluster.\n\n\n\n\n@from(eventtable = 'hazelcast', cluster.name = 'cluster_a', cluster.password = 'pass@cluster_a', cluster.addresses='192.168.1.1:5700,192.168.1.2.5700')\ndefine table RoomTypeTable(roomNo int, type string);\n\n\n\n\nRDBMS Event Table\n\n\nAn event table can be backed with an RDBMS event store using the \nFrom\n annotation. You can also provide the connection instructions to the event table with this annotation. The RDBMS table name can be different from the event table name defined in Siddhi, and Siddhi always refers to the defined event table name. However the defined event table name cannot be same as an already existing stream name because syntactically, both are considered the same in the Siddhi Query Language.\n\n\n*The RDBMS event table has been tested with the following databases:\n\n\n\n\nMySQL\n\n\nH2\n\n\nOracle*\n\n\n\n\nExample\n\n\n\n\nCreating an event table backed by an RDBMS table\n\n\n\n\nThe following query creates an event table named \nRoomTypeTable\n with the attributes \nroomNo\n (an \nINT\n attribute) and \ntype\n (a \nSTRING\n attribute), backed by an RDBMS table named \nRoomTable\n from the data source named \nAnalyticsDataSource\n.\n\n\n@From(eventtable='rdbms', datasource.name='AnalyticsDataSource', table.name='RoomTable')\ndefine table RoomTypeTable (roomNo int, type string);\n\n\n\n\nThe datasource.name given here is injected to the Siddhi engine by the CEP/DAS server. To configure data sources in the CEP/DAS, see WSO2 Administration Guide - Configuring an RDBMS Datasource.\n+ Creating an event table backed by a MySQL table\nThe following query creates an event table named RoomTypeTable with the attributes roomNo (an INT attribute) and type (a STRING attribute), backed by a MySQL table named \nRoomTable\n from the \ncepdb\n database located at \nlocalhost:3306\n with \nroot\n as both the username and the password.\n\n\nCaching Events\n\n\nSeveral caches can be used with RDBMS backed event tables in order to reduce I/O operations and improve their performance. Currently all cache implementations provide size-based algorithms.\n\n\nThe following elements are added with the Fromannotation to add caches.\n\n\n\n\n\n\ncache\n: This specifies the cache implementation to be added. The supported cache implementations are as follows.\n\n\n\n\n\n\nBasic\n: Events are cached in a First-In-First-Out manner where the oldest event is dropped when the cache is full.\n\n\n\n\n\n\nLRU\n (Least Recently Used): The least recently used event is dropped when the cache is full.\n\n\n\n\n\n\nLFU\n (Least Frequently Used): The least frequently used event is dropped when the cache is full.\n\n\n\n\n\n\nIf the \ncache\n element is not specified, the basic cache is added by default.\n\n\n\n\n\n\ncache.size\n: This defines the size of the cache. If this element is not added, the default cache size of 4096 is added by default.\n\n\n\n\n\n\nExample\n\n\nThe following query creates an event table named \nRoomTypeTable\n with the attributes \nroomNo\n (an \nINT\n attribute) and \ntype\n (a \nSTRING\n attribute), backed by an RDBMS table using the LRU algorithm for caching 3000 events.\n\n\n@From(eventtable='rdbms', datasource.name='AnalyticsDataSource', table.name='RoomTable', cache='LRU', cache.size='3000')define table RoomTypeTable (roomNo int, type string);\n\n\n\n\nUsing Bloom filters\n\n\nA Bloom Filter is an algorithm or an approach that can be used to perform quick searches. If you apply a Bloom Filter to a data set and carry out an \nisAvailablecheck\n on that specific Bloom Filter instance, an accurate answer is returned if the search item is not available. This allows the quick improvement of updates, joins and \nisAvailable\n checks.\n\n\nExample\n\n\nThe following example shows how to include Bloom filters in an event table update query.\n\n\ndefine stream StockStream (symbol string, price float, volume long);define stream CheckStockStream (symbol string, volume long);\n@from(eventtable = 'rdbms' ,datasource.name = 'cepDB' , table.name = 'stockInfo' , bloom.filters = 'enable')\ndefine table StockTable (symbol string, price float, volume long);\n\n@info(name = 'query1')\nfrom StockStream\ninsert into StockTable ;\n\n@info(name = 'query2')\nfrom CheckStockStream[(StockTable.symbol==symbol) in StockTable]\ninsert into OutStream;\n\n\n\n\nSupported Event Table Operators\n\n\nThe following event table operators are supported for Siddhi.\n\n\nInsert into\n\n\nSyntax\n\n\nfrom \ninput stream name\n \nselect \nattribute name\n, \nattribute name\n, ...\ninsert into \ntable name\n\n\n\n\n\nTo insert only the specified output event category, use the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword between \ninsert\n and \ninto\n keywords. For more information, see Output Event Categories.\n\n\nPurpose\n\n\nTo store filtered events in a specific event table.\n\n\nParameters\n\n\n\n\n\n\ninput stream name\n: The input stream from which the events are taken to be stored in the event table.\n\n\n\n\n\n\nattribute name\n: Attributes of the chosen events that are selected to be saved in the event table.\n\n\n\n\n\n\ntable name\n: The name of the event table in which the events should be saved.\n\n\n\n\n\n\nExample\n\n\nThe following query inserts all the temperature events from the \nTempStream\n event stream to the \nTempTable\n event table.\n\n\nfrom TempStream\nselect *\ninsert into TempTable;\n\n\n\n\nDelete\n\n\nSyntax\n\n\nfrom \ninput stream name\n \nselect \nattribute name\n, \nattribute name\n, ...\ndelete \ntable name\n\n    on \ncondition\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which events are selected to be deleted. When specifying this condition, the attribute names should be referred to with the table name.\nTo delete only the specified output category, use the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword. For more information, see Output Event Categories.\n\n\nPurpose\n\n\nTo delete selected events that are stored in a specific event table.\n\n\nParameters\n\n\n\n\n\n\ninput stream name\n: The input stream that is the source of the events stored in the event table.\n\n\n\n\n\n\nattribute name\n: Attributes to which the given condition is applied in order to filter the events to be deleted.\n\n\n\n\n\n\ntable name\n: The name of the event table from which the filtered events are deleted.\n\n\n\n\n\n\ncondition\n: The condition based on which the events to be deleted are selected.\n\n\n\n\n\n\nExample\n\n\nThe following query deletes all the entries in the \nRoomTypeTable\n event table that have a room number that matches the room number in any event in the \nDeleteStream\n event stream.\n\n\ndefine table RoomTypeTable (roomNo int, type string);\ndefine stream DeleteStream (roomNumber int);\n\nfrom DeleteStream\ndelete RoomTypeTable\n    on RoomTypeTable.roomNo == roomNumber;\n\n\n\n\nUpdate\n\n\nSyntax\n\n\nfrom \ninput stream name\n \nselect \nattribute name\n as \ntable attribute name\n, \nattribute name\n as \ntable attribute name\n, ...\nupdate \ntable name\n\n    on \ncondition\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which events are selected to be updated. When specifying this condition, the attribute names should be referred to with the table name.\nTo update only the specified output category, use the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword. For more information, see Output Event Categories.\n\n\nPurpose\n\n\nTo update selected events in an event table.\n\n\nParameters\n\n\n\n\n\n\ninput stream name\n: The input stream that is the source of the events stored in the event table.\n\n\n\n\n\n\nattribute name\n: Attributes to which the given \ncondition\n is applied in order to filter the events to be updated.\n\n\n\n\n\n\ntable name\n: The name of the event table in which the filtered events should be updated.\n\n\n\n\n\n\ncondition\n: The condition based on which the events to be updated are selected.\n\n\n\n\n\n\nExample\n\n\nThe following query updates room type of all the events in the \nRoomTypeTable\n event table that have a room number that matches the room number in any event in the \nUpdateStream\n event stream.\n\n\ndefine table RoomTypeTable (roomNo int, type string);\ndefine stream UpdateStream (roomNumber int, roomType string);\n\nfrom UpdateStream\nselect roomType as type\nupdate RoomTypeTable\n    on RoomTypeTable.roomNo == roomNumber;\n\n\n\n\nInsert Overwrite\n\n\nSyntax\n\n\nfrom \ninput stream name\n \nselect \nattribute name\n as \ntable attribute name\n, \nattribute name\n as \ntable attribute name\n, ...\ninsert overwrite \ntable name\n\n    on \ncondition\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which events are selected to be inserted or overwritten. When specifying this condition, the attribute names should be referred to with the table name.\nWhen specifying the \ntable attribute\n name, the attributes should be specified with the same name specified in the event table, allowing Siddhi to identify the attributes that need to be updated/inserted in the event table.\n\n\nPurpose\n\n\nParameters\n\n\n\n\n\n\ninput stream name\n: The input stream that is the source of the events stored in the event table.\n\n\n\n\n\n\nattribute name\n: Attributes to which the given \ncondition\n is applied in order to filter the events to be inserted or over-written.\n\n\n\n\n\n\ntable name\n: The name of the event table in which the filtered events should be inserted or over-written.\n\n\n\n\n\n\ncondition\n : The condition based on which the events to be inserted or over-written are selected.\n\n\n\n\n\n\nExample\n\nThe following query searches for events in the \nUpdateTable\n event table that have room numbers that match the same in the \nUpdateStream\n stream. When such events are founding the event table, they are updated. When a room number available in the stream is not found in the event table, it is inserted from the stream.\n ```sql\n define table RoomTypeTable (roomNo int, type string);\n define stream UpdateStream (roomNumber int, roomType string);\n\n\nfrom UpdateStream\n select roomNumber as roomNo, roomType as type\n insert overwrite RoomTypeTable\n     on RoomTypeTable.roomNo == roomNo;\n ```\n\n\nIn\n\n\nSyntax\n\n\ncondition\n in \ntable name\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which events are selected to be inserted or overwritten. When specifying this condition, the attribute names should be referred to with the table name.\n\n\nPurpose\n\n\nParameters\n\n\nExample\n\n\ndefine table ServerRoomTable (roomNo int);\ndefine stream TempStream (deviceID long, roomNo int, temp double);\n\nfrom TempStream[ServerRoomTable.roomNo == roomNo in ServerRoomTable]\ninsert into ServerTempStream;\n\n\n\n\nJoin\n\n\nSyntax\n\n\nfrom \ninput stream name\n#window.length(1) join \ntable_name\n\n    on \ninput stream name\n.\nattribute name\n \ncondition\n \ntable_name\n.\ntable attribute name\n\nselect \ninput stream name\n.\nattribute name\n, \ntable_name\n.\ntable attribute name\n, ...\ninsert into \noutput stream name\n\n\n\n\n\nAt the time of joining, the event table should not be associated with window operations because an event table is not an active construct. Two event tables cannot be joined with each other due to the same reason.\n\n\nPurpose\n\nTo allow a stream to retrieve information from an event table.\n\n\nParameters\n\n\nExample\n\n\nThe following query performs a join to update the room number of the events in the \nTempStream\n stream with that of the corresponding events in the \nRoomTypeTable\n event table, and then inserts the updated events into the \nEnhancedTempStream\n stream.\n\n\ndefine table RoomTypeTable (roomNo int, type string);\ndefine stream TempStream (deviceID long, roomNo int, temp double);\n\nfrom TempStream join RoomTypeTable\n    on RoomTypeTable.roomNo == TempStream.roomNo\nselect deviceID, RoomTypeTable.roomNo as roomNo, type, temp\ninsert into EnhancedTempStream;\n\n\n\n\nEvent Window\n\n\nAn event window is a window that can be shared across multiple queries. Events are inserted from one or more streams. The event window publishes current and/or expired events as the output. The time at which these events are published depends on the window type.\n\n\nSyntax\n\n\nThe following is the syntax for an event window.\n\n\ndefine window \nevent window name\n (\nattribute name\n \nattribute type\n, \nattribute name\n \nattribute type\n, ... ) \nwindow type\n(\nparameter\n, \nparameter\n, \u2026) \noutput event type\n;\n\n\n\n\nExamples\n\n\n\n\nReturning all output categories\n\n\n\n\nIn the following query, the window type is not specified in the window definition. Therefore, it emits both current and expired events as the output.\n\n\ndefine window SensorWindow (name string, value float, roomNo int, deviceID string) timeBatch(1 second);\n\n\n\n\n\n\nReturning a specified output category\n\n\n\n\nIn the following query, the window type is \noutput all events\n. Therefore, it emits both current and expired events as the output.\n\n\ndefine window SensorWindow (name string, value float, roomNo int, deviceID string) timeBatch(1 second) output all events;\n\n\n\n\nSupported Event Window Operators\n\n\nThe following operators are supported for event windows.\n\n\nInsert Into\n\n\nSyntax\n\n\nfrom \ninput stream name\n \nselect \nattribute name\n, \nattribute name\n, ...\ninsert into \nwindow name\n\n\n\n\n\nTo insert only the specified output event category, use the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword between \ninsert\n and \ninto\n keywords. For more information, see Output Event Categories.\n\n\nPurpose\n\n\nTo insert events from an event stream to a window.\n\n\nParameters\n\n\n\n\n\n\ninput stream name\n:  The event stream from which events are inserted into the event window.\n\n\n\n\n\n\nattribute name\n: The name of the attributes with which the events are inserted from the event stream to the event window. Multiple attributes can be specified as a comma separated list.\n\n\n\n\n\n\nwindow name\n: The event window to which events are inserted from the event stream.\n\n\n\n\n\n\nExample\n\n\nThe following query inserts both current and expired events from an event stream named \nsensorStream\n to an event window named \nsensorWindow\n.\n\n\nfrom SensorStream\ninsert into SensorWindow;\n\n\n\n\nOutput\n\n\nAn event window can be used as a stream in any query. However, an ordinary window cannot be applied to the output of an event window.\n\n\nSyntax\n\n\nfrom \nwindow name\n \nselect \nattribute name\n, \nattribute name\n, ...\ninsert into \nevent stream name\n\n\n\n\n\nPurpose\n\n\nTo inject the output of an event window into an event stream.\n\n\nParameters\n\n\n\n\n\n\nwindow name\n: The event window of which the output is injected into the specified stream.\n\n\n\n\n\n\nattribute name\n: The name of the attributes with which the events are inserted from the event stream to the event window. Multiple attributes can be specified as a comma separated list.\n\n\n\n\n\n\nevent stream name\n: The event stream to which the output of the specified event window is injected.\n\n\n\n\n\n\nExample\n\nThe following query selects the name and the maximum values for the \nvalue\n and \nroomNo\n attributes from an event window named \nSensorWindow\n, and inserts them into an event stream named \nMaxSensorReadingStream\n.\n\n\nfrom SensorWindow\nselect name, max(value) as maxValue, roomNo\ninsert into MaxSensorReadingStream;\n\n\n\n\nJoin\n\n\nExample\n\n\n define stream TempStream(deviceID long, roomNo int, temp double);\n define stream RegulatorStream(deviceID long, roomNo int, isOn bool);\n define window TempWindow(deviceID long, roomNo int, temp double) time(1 min);\n\n from TempStream[temp \n 30.0]\n insert into TempWindow;\n\n from TempWindow\n join RegulatorStream[isOn == false]#window.length(1) as R\n on TempWindow.roomNo == R.roomNo\n select TempWindow.roomNo, R.deviceID, 'start' as action\n insert into RegulatorActionStream;\n\n\n\n\nEvent Trigger\n\n\nEvent triggers allow events to be created periodically based on a specified time interval.\n\n\nSyntax\n\n\nThe following is the syntax for an event trigger definition.\n\n\ndefine trigger \ntrigger name\n at {'start'| every \ntime interval\n| '\ncron expression\n'};\n\n\n\n\nExamples\n\n\n\n\nTriggering events regularly at specific time intervals\n\n\n\n\nThe following query triggers events every 5 minutes.\n\n\n define trigger FiveMinTriggerStream at every 5 min;\n\n\n\n\n\n\nTriggering events at a specific time on specified days\nThe following query triggers an event at 10.15 AM every Monday, Tuesday, Wednesday, Thursday and Friday.\n\n\n\n\n define trigger FiveMinTriggerStream at '0 15 10 ? * MON-FRI';\n\n\n\n\n\nSiddhi Logger\n\n\nThe Siddhi Logger logs events that arrive in different logger priorities such as \nINFO\n, \nDEBUG\n, \nWARN\n, \nFATAL\n, \nERROR\n, \nOFF\n, and \nTRACE\n.\n\n\nSyntax\n\n\nThe following is the syntax for a query with a Siddhi logger.\n\n\nvoid\n log(\nstring\n priority, \nstring\n logMessage, \nbool\n isEventLogged)\n\n\n\n\nThe parameters configured are as follows.\n\n\n\n\n\n\nprioroty\n: The logging priority. Possible values are \nINFO\n, \nDEBUG\n, \nWARN\n, \nFATAL\n, \nERROR\n, \nOFF\n, and \nTRACE\n. If no value is specified for this parameter, \nINFO\n is printed as the priority by default.\n\n\n\n\n\n\nlogMessage\n: This parameter allows you to specify a message to be printed in the log.\n\n\n\n\n\n\nisEventLogged\n: This parameter specifies whether the event body should be included in the log. Possible values are \ntrue\n and \nfalse\n. If no value is specified, the event body is not printed in the log by default.\n\n\n\n\n\n\nExamples\n\n\n\n\nThe following query logs the event with the \nINFO\n logging priority. This is because the priority is not specified.\n\n\n\n\nfrom StockStream#log()\nselect *\ninsert into OutStream;\n\n\n\n\n\n\nThe following query logs the event with the \nINFO\n logging priority (because the priority is not specified) and the \ntest message\n text.\n\n\n\n\nfrom StockStream#log('test message')\nselect *\ninsert into OutStream;\n\n\n\n\n\n\nThe following query logs the event with the \nINFO\n logging priority because a priority is not specified. The event itself is printed in the log.\n\n\n\n\nfrom StockStream#log(true)\nselect *\ninsert into OutStream;\n\n\n\n\n\n\nThe following query logs the event with the \nINFO\n logging priority (because the priority is not specified) and the \ntest message\n text. The event itself is printed in the log.\n\n\n\n\nfrom StockStream#log('test message', true)\nselect *\ninsert into OutStream;\n\n\n\n\n\n\nThe following query logs the event with the \nWARN\n logging priority and the \ntest message\n text.\n\n\n\n\nfrom StockStream#log('warn','test message')\nselect *\ninsert into OutStream;\n\n\n\n\n\n\nThe following query logs the event with the \nWARN\n logging priority and the \ntest message\n text.  The event itself is printed in the log.\n\n\n\n\nfrom StockStream#log('warn','test message',true)\nselect *\ninsert into OutStream;\n\n\n\n\nEval Script\n\n\nEval script allows Siddhi to process events using other programming languages by including their functions in the Siddhi queries. Eval script functions can be defined like event tables or streams and referred in the queries as Inbuilt Functions of Siddhi.\n\n\nSyntax\n\n\nThe following is the syntax for a Siddhi query with an Eval Script definition.\n\n\ndefine function \nfunction name\n[\nlanguage name\n] return \nreturn type\n {\n    \noperation of the function\n\n};\n\n\n\n\nThe following parameters are configured when defining an eval script.\n\n\n\n\n\n\nfunction name\n:  The name of the function from another programming language that should be included in the Siddhi query.\n\n\n\n\n\n\nlanguage name\n: The name of the other programming language from which the function included in the Siddhi query is taken. The languages supported are JavaScript, R and Scala.\n\n\n\n\n\n\nreturn type\n: The return type of the function defined. The return type can be \nint\n, \nlong\n, \nfloat\n, \ndouble\n, \nstring\n, \nbool\n or \nobject\n. Here the function implementer should be responsible for returning the output on the defined return type for proper functionality. \n\n\n\n\n\n\noperation of the function\n: Here, the execution logic of the defined logos should be added. This logic should be written in the language specified in the \nlanguage name\n parameter, and the return should be of the type specified in the \nreturn type\n parameter.\n\n\n\n\n\n\nExamples\n\n\n\n\nConcatenating a JavaScript function\n\n\n\n\nThe following query performs the concatenating function of the JavaScript language and returns the output as a string.\n\n\ndefine function concatFn[JavaScript] return string {\n    var str1 = data[0];\n    var str2 = data[1];\n    var str3 = data[2];\n    var responce = str1 + str2 + str3;\n    return responce;\n};\n\ndefine stream TempStream(deviceID long, roomNo int, temp double);\n\nfrom TempStream\nselect concatFn(roomNo,'-',deviceID) as id, temp \ninsert into DeviceTempStream;\n\n\n\n\n\n\nConcatenating an R function\n\n\n\n\nThe following query performs the concatenating function of the R language and returns the output as a string.\n\n\ndefine function concatFn[R] return string {\n    return(paste(data, collapse=\n));\n};\n\ndefine stream TempStream(deviceID long, roomNo int, temp double);\n\nfrom TempStream\nselect concatFn(roomNo,'-',deviceID) as id, temp\ninsert into DeviceTempStream;\n\n\n\n\n\n\nConcatenating a Scala function\n\n\n\n\nThe following query performs the concatenating function of the Scala language and returns the output as a string.\n\n\ndefine function concatFn[Scala] return string {\n    var concatenatedString =\n     for(i \n- 0 until data.length){\n         concatenatedString += data(i).toString\n     }\n     concatenatedString\n};\n\ndefine stream TempStream(deviceID long, roomNo int, temp double);\n\nfrom TempStream\nselect concatFn(roomNo,'-',deviceID) as id, temp\ninsert into DeviceTempStream;", 
            "title": "Siddhi Query Guide"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#siddhi-query-language-guide-40", 
            "text": "", 
            "title": "Siddhi Query Language Guide 4.0"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#event-streams", 
            "text": "The event stream definition defines the event stream schema. An event stream definition contains a unique name and a \nset of attributes assigned specific types, with uniquely identifiable names within the stream.  Purpose \nTo define the schema based on which events are selected to be processed in the execution plan to which the event stream\n is attached.  Syntax  The following is the syntax of a query that defines a new event stream.  `define stream  stream name  ( attribute name   attribute type ,  attribute name   attribute type , ... );`  The following parameters are configured in an event stream definition.     Parameter  Description      stream name  The name of the event stream to be created.    attribute name   attribute type  The schema of an event stream is defined by adding the name and the type of each attribute as a value pair.    attribute name : A unique name for the attribute.      attribute type : The data type of the attribute value. This can be  STRING ,  INT ,  LONG ,  DOUBLE ,  FLOAT  or  BOOLEAN .     Example  `define stream TempStream (deviceID long, roomNo int, temp double);`\nThe above creates an event stream named TempStream with the following attributes.   deviceID  of the  long  attribute type  roomNo  of the  int  attribute type  temp  of the  double  attribute type", 
            "title": "Event streams"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#event-sources", 
            "text": "", 
            "title": "Event sources"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#event-sinks", 
            "text": "", 
            "title": "Event sinks"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#filters", 
            "text": "Filters are included in queries to filter information from input streams based on a specified condition.  Purpose \nA filter allows you to separate events that match a specific condition as the output, or for further processing.  Syntax  Filter conditions should be defined in square brackets next to the input stream name as shown below.  from  input stream name [ filter condition ]select  attribute name ,  attribute name , ...\ninsert into  output stream name   The following parameters are configured in a filter definition.     Parameter  Description      input stream name  The event stream from which events should be selected.    filter condition  The condition based on which the events should be filtered to be inserted into the output stream.    attribute name  The specific attributes of which the values should be inserted into the output stream. Multiple     attributes can be added as a list of comma-separated values.    output stream name  The event stream to which the filtered events should be inserted.     Example  The following query filters all server rooms of which the temperature is greater than 40 degrees. The filtered events\nare taken from the  TempStream  input stream and inserted into the  HighTempStream  output stream.  from TempStream [(roomNo  = 100 and roomNo   110) and temp   40 ]select roomNo, temp\ninsert into HighTempStream;", 
            "title": "Filters"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#windows", 
            "text": "Windows allow you to capture a subset of events based on a specific criterion from an input event stream for calculation. Each input stream can only have maximum of one window.  Purpose  To create subsets of events within an event stream based on time or length. Event windows always operate as sliding windows.  e.g., If you define a filter condition to find the maximum value out of every 10 events, you need to define a length window of 10 events. This window operates as a sliding window where the following 3 subsets can be identified in a list of 12 events received in a sequential order.     Subset  Event Range      1  1-10    2  2-11    3  3-12     Syntax  The  #window  prefix should be inserted next to the relevant event stream in order to add a window.  from  input stream name [ filter condition ]#window. window name ( parameter ,  parameter , ... )select  attribute name ,  attribute name , ...\ninsert into  output stream name   The following parameters are configured in a window definition.     Parameter  Description      input stream name  The stream to which the window is applied.    filter condition  The filter condition based on which events are filtered from the defined window.    window name  The name of the window. The name should include the following information:   The type of the window. The supported inbuilt windows are listed in Inbuilt Windows.   The range of the window in terms of the time duration or the number of events.   e.g, time(10 min) defines a time window of 10 minutes.    parameter     attribute name  The attributes of the events selected from the window that should be inserted into the output stream. Multiple attributes can be specified as a comma-separated list.    output stream name      For details on inbuilt windows supported for Siddhi, see Inbuilt Windows.\n   For details on how to manipulate window output based on event categories, see Output Event Categories.\n   For information on how to perform aggregate calculations within windows, see Aggregate Functions.", 
            "title": "Windows"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#aggregate-functions", 
            "text": "Aggregate functions perform aggregate calculations within defined windows.For the complete list of inbuilt aggregate\nfunctions supported see Inbuilt Aggregate Functions.  Syntax  from  input_stream #window. window_name select  aggregate_function ( attribute_name ) as  attribute_name ,  attribute1_name ,  attribute2_name , ...\ninsert  output_event_category  into  output_stream ;  The parameters configured are as follows:  Example \nThe following query calculates the average for the temp attribute of the  TempStream  input stream within each time\nwindow of 10 minutes. Then it emits the events to the  AvgTempStream  output stream. Each event emitted to the output\nstream has the following.   avgTemp  attribute with the average temperature calculated as the value.  roomNo  and deviceID attributes with their original values from the input stream.   from TempStream#window.time(10 min)select avg(temp) as avgTemp, roomNo, deviceID\ninsert all events into AvgTempStream;", 
            "title": "Aggregate functions"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#aggregate-function-types", 
            "text": "The following aggregate function types are supported", 
            "title": "Aggregate function types"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#group-by", 
            "text": "Group By  allows you to group the aggregate based on specified attributes.  Syntax  from  input_stream #window. window_name select  aggregate_function ( attribute_name ) as  attribute_name ,  attribute1_name ,  attribute2_name , ...\ngroup by  attribute_name ,  attribute1_name ,  attribute2_name , ...\ninsert into  output_stream ;  The parameters configured are as follows.  Example \nThe following query calculates the average temperature ( avgTemp ) per room number ( roomNo ) within each sliding time\nwindow of 10 minutes ( #window.time(10min) ) in the  TempStream  input stream, and inserts the output into the AvgTempStream  output stream.  ` br from TempStream#window.time(10 min)select avg(temp) as avgTemp, roomNo, deviceID /br  br group by roomNo, deviceID /br \ninsert into AvgTempStream;`", 
            "title": "Group By"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#having", 
            "text": "Having allows you to filter events after aggregation and after processing at the selector.  Syntax  ` br from  input_stream #window. window_name select  aggregate_function ( attribute_name ) as  attribute_name ,  attribute1_name ,  attribute2_name , ... /br  br group by  attribute_name ,  attribute1_name ,  attribute2_name , ... /br  br having  condition /br \n insert into  output_stream ;  The query parameters configured are as follows.  Example  The following query calculates the average temperature for the last 10 minutes, and alerts if it exceeds 30 degrees.  ` br from TempStream#window.time(10 min)select avg(temp) as avgTemp, roomNo /br  br group by roomNo /br  br having avgTemp   30 /br \n insert into AlertStream;", 
            "title": "Having"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#inbuilt-aggregate-functions", 
            "text": "Aggregate functions are used to perform operations such as sum on aggregated set of events through a window. Usage of \nan aggregate function is as follows.  @info(name = 'query1')\nfrom cseEventStream#window.timeBatch(1 sec)\nselect symbol, sum(price) as price\ninsert into resultStream;", 
            "title": "Inbuilt aggregate functions"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#sum", 
            "text": "Detail  Value      Syntax  long|double  sum( int|long|double|float  arg)    Extension Type  Aggregate Function    Description  Calculates the sum for all the events.    Parameter  The value that needs to be summed.    Return Type  Returns long if the input parameter type is  int  or  long , and returns double if the input parameter type is  float  or  double .    Examples  sum(20)  returns the sum of 20s as a long value for each event arrival and expiry.   sum(temp)  returns the sum of all temp attributes based on each event arrival and expiry.", 
            "title": "Sum"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#average", 
            "text": "Detail  Value      Syntax  double  avg( int|long|double|float  arg)    Extension Type  Aggregate Function    Description  Calculates the average for all the events.    Parameter  arg  : The value that need to be averaged.    Return Type  Returns the calculated average value as a double.    Example  avg(temp)  returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "Average"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#maximum", 
            "text": "Detail  Value      Syntax  int|long|double|float  min( int|long|double|float  arg)    Extension Type  Aggregate Function    Description  Returns the minimum value for all the events.    Parameter }  arg : The value that needs to be compared to find the minimum value.    Return Type  Returns the minimum value in the same type as the input.    Example  min(temp)  returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "Maximum"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#minimum", 
            "text": "Detail  Value      Syntax  int|long|double|float  min( int|long|double|float  arg)    Extension Type  Aggregate Function    Description  Returns the minimum value for all the events.    Parameter  arg : The value that needs to be compared to find the minimum value.    Return Type  Returns the minimum value in the same type as the input.    Example  min(temp)  returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "Minimum"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#count", 
            "text": "Detail  Value      Syntax  long  count()    Extension Type  Aggregate Function    Description  Returns the count of all the events.    Return Type  Returns the event count as a long.    Example  count()  returns the count of all the events.", 
            "title": "Count"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#standard-deviation", 
            "text": "Detail  Value      Syntax  double  stddev( int|long|double|float  arg)    Extension  Aggregate Function    Description  Returns the calculated standard deviation for all the events.    Parameter  arg :The value that should be used to calculate the standard deviation.", 
            "title": "Standard Deviation"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#distinct-count", 
            "text": "Detail  Value      Syntax  long  distinctcount( int|long|double|float|string  arg)    Extension  Aggregate Function    Description  Returns the count of distinct occurrences for a given arg.    Parameter  arg : The value that should be counted.    Return Type  Returns the count of distinct occurances for a given arg.    Example  distinctcount(pageID)  for the following output returns  3 .   \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\"", 
            "title": "Distinct Count"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#forever-maximum", 
            "text": "Detail  Value      Syntax  int|long|double|float  maxForever ( int|long|double|float  arg)    Extension  Aggregate Function    Description  This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.    Parameter  arg : The value that needs to be compared to find the maximum value.    Return Type  Returns the maximum value in the same data type as the input.    Example  maxForever(temp)  returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "Forever Maximum"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#forever-minimum", 
            "text": "Detail  Value      Syntax  int|long|double|float  minForever ( int|long|double|float  arg)    Extension  Aggregate Function    Description  This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.    Parameter  arg : The value that needs to be compared to find the minimum value.    Return Type  Returns the minimum value in the same data type as the input.    Example  minForever(temp)  returns the minimum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "Forever Minimum"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#inbuilt-windows", 
            "text": "WSO2 Siddhi supports the following inbuilt windows.", 
            "title": "Inbuilt windows"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#time", 
            "text": "Detail  Value      Syntax  event  time( int|long|time  windowTime)    Extension Type  Window    Description  A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.    Parameter  windowTime : The sliding time period for which the window should hold events.    Return Type  Returns current and expired events.    Examples  time(20)  for processing events that arrived within the last 20 milliseconds. time(2 min)  for processing events that arrived within the last 2 minutes.", 
            "title": "time"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#timebatch", 
            "text": "Detail  Value      Syntax  event  timeBatch( int|long|time  windowTime,  int  startTime )    Extension  Window    Description  A batch (tumbling)  time window  that holds events that arrive during  windowTime  periods, and gets updated for each  windowTime .    Parameters  windowTime : The batch time period for which the window should hold events.   startTime (Optional) : This specifies an offset in milliseconds in order to start the window at a time different to the standard time.    Return Type  Returns current and expired events.    Examples  timeBatch(20)  processes events that arrive every 20 milliseconds. timeBatch(2 min)  processes events that arrive every 2 minutes. timeBatch(10 min, 0)  processes events that arrive every 10 minutes starting from the 0th minute. e.g., If you deploy your window at 08:22 and the first event arrives at 08:26, this event occurs within the time window 08.20 - 08.30. Therefore, this event is emitted at 08.30.   timeBatch(10 min, 1000*60*5) processes events that arrive every 10 minutes starting from 5th minute. e.g., If you deploy your window at 08:22 and the first event arrives at 08:26, this event occurs within the time window 08.25 - 08.35. Therefore, this event is emitted at 08.35.", 
            "title": "timeBatch"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#length", 
            "text": "Detail  Value      Syntax  event  length( int  windowLength)    Extension Type  Window    Description  A sliding length window that holds the last  windowLength  events at a given time, and gets updated for each arrival and expiry.    Parameter  windowLength : The number of events that should be included in a sliding length window.    Return Type \"  Returns current and expired events.    Examples  length(10)  for processing the last 10 events. length(200)  for processing the last 200 events.", 
            "title": "length"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#lengthbatch", 
            "text": "Detail  Value      Syntax  event  lengthBatch( int  windowLength)    Extension Type  Window    Description  A batch (tumbling) length window that holds a number of events specified as the  windowLength . The window is updated each time a batch of events that equals the number specified as the  windowLength arrives.    Parameter  windowLength :The number of events the window should tumble.    Return Type  Returns current and expired events.    Examples  lengthBatch(10)  for processing 10 events as a batch. lengthBatch(200)  for processing 200 events as a batch.", 
            "title": "lengthBatch"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#externaltime", 
            "text": "Detail  Value      Syntax  event  externalTime( long  timestamp,  int|long|time  windowTime)    Extension Type  Window    Description  A sliding time window based on external time. It holds events that arrived during the last  windowTime  period from the external timestamp, and gets updated on every monotonically increasing timestamp.    Parameter  windowTime :The sliding time period for which the window should hold events.    Return Type  Returns current and expired events.    Examples  externalTime(eventTime,20)  for processing events arrived within the last 20 milliseconds from the  eventTime . externalTime(eventTimestamp, 2 min)  for processing events arrived within the last 2 minutes from the  eventTimestamp .", 
            "title": "externalTime"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#cron", 
            "text": "Detail  Value      Syntax  event  cron( string  cronExpression)    Extension Type  Window    Description  This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.    Parameter  cronExpression : cron expression that represents a time schedule.    Return Type  Returns current and expired events.    Examples  cron('*/5 * * * * ?')  returns processed events as the output every 5 seconds.", 
            "title": "cron"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#firstunique", 
            "text": "Detail  Value      Syntax  event  firstUnique( string  attribute)    Extension  Window    Description  First unique window processor keeps only the first events that are unique according to the given unique attribute.    Parameter : attribute : The attribute that should be checked for uniqueness.     Return Type  Returns current and expired events.    Examples  firstUnique(ip)  returns the first event arriving for each unique ip.", 
            "title": "firstUnique"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#unique", 
            "text": "Detail  Value      Syntax  event   unique ( string   attribute )    Extension  Window    Description  This window keeps only the latest events that are unique according to the given unique attribute.    Parameter  attribute : The attribute that should be checked for uniqueness.    Return Type  Returns current and expired events.    Example  unique(ip)  returns the latest event that arrives for each unique  ip .", 
            "title": "unique"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#sort", 
            "text": "Detail  Value      Syntax  event  sort( int  windowLength) event  sort( int  windowLength,  string  attribute,  string  order) event  sort( int  windowLength,  string  attribute,  string  order, .. ,  string  attributeN,  string  orderN)    Extension  Window    Description  This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.    Parameter  attribute : The attribute that should be checked for the order.    Return Type  Returns current and expired events.    Example  sort(5, price, 'asc')  keeps the events sorted by  price  in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#frequent", 
            "text": "Detail  Value      Syntax  event  frequent( int  eventCount) event  frequent( int  eventCount,  string  attribute, .. ,  string  attributeN)    Extension Type  Window    Description  This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.    Parameter  eventCount : The number of most frequent events to be emitted to the stream.    Return Type  The number of most frequent events to be emitted to the stream.    Examples  frequent(2)  returns the 2 most frequent events. frequent(2, cardNo)  returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#lossyfrequent", 
            "text": "Detail  Value      Syntax  event  lossyFrequent( double  supportThreshold,  double  errorBound) event  lossyFrequent( double  supportThreshold,  double  errorBound,  string  attribute, .. ,  string  attributeN)    Extension Type  Window    Description  This window identifies and returns all the events of which the current frequency exceeds the value specified for the  supportThreshold  parameter.    Parameters  errorBound : The error bound value. attribute :The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.    Return Type  Returns current and expired events.    Examples  lossyFrequent(0.1, 0.01)  returns all the events of which the current frequency exceeds  0.1 , with an error bound of  0.01 . 'lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3 , with an error bound of 0.05`.", 
            "title": "lossyFrequent"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#externaltimebatch", 
            "text": "Detail  Value      Syntax  event  externalTimeBatch( long  timestamp,  int|long|time  windowTime,  int|long|time  startTime,  int|long|time  timeout)    Extension Type  Window    Description  A batch (tumbling) time window based on external time, that holds events arrived during  windowTime  periods, and gets updated for every  windowTime .    Parameters  timestamp : The time that the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. windowTime : The batch time period for which the window should hold events. startTime  (Optional): User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as  startTime . When  startTime  is not given, initial value of  timestamp  is used as the default. timeout (Optional): Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. If timeout is not provided, system waits till an event from next batch arrives to flush current batch.    Return Type  Returns current and expired events.    Examples  externalTimeBatch(eventTime,20)  for processing events that arrive every 20 milliseconds from the  eventTime . externalTimeBatch(eventTimestamp, 2 min)  for processing events that arrive every 2 minutes from the  eventTimestamp . externalTimeBatch(eventTimestamp, 2 sec, 0)  for processing events that arrive every 2 seconds from the  eventTimestamp . This starts on 0th millisecond of an hour. externalTimeBatch(eventTimestamp, 2 sec, eventTimestamp, 100)  for processing events that arrive every 2 seconds from the  eventTimestamp . This considers the  eventTimeStamp  of the first event as the start time, and waits 100 milliseconds for the arrival of a new event before flushing the current batch.", 
            "title": "externalTimeBatch"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#timelength", 
            "text": "Detail  Value      Syntax  event  timeLength (   int|long|time     windowTime,    int    windowLength )    Extension Type  Window    Description  A sliding time window that, at a given time holds the last windowLength events that arrived during last windowTime period, and gets updated for every event arrival and expiry.    Parameters  windowTime : The sliding time period for which the window should hold events. windowLength : The number of events that should be be included in a sliding length window.    Return Type  Returns current and expired events.    Examples  timeLength(20 sec, 10)  for processing the last 10 events that arrived within the last 20 seconds. timeLength(2 min, 5)  for processing the last 5 events that arrived within the last 2 minutes.", 
            "title": "timeLength"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#uniqueexternaltimebatch", 
            "text": "Detail  Value      Syntax  event  uniqueExternalTimeBatch( string  attribute,  long  timestamp,  int|long|time  windowTime,  int|long|time  startTime,  int|long|time  timeout,  bool  replaceTimestampWithBatchEndTime )    Extension Type  Window    Description  A batch (tumbling) time window based on external time that holds latest unique events that arrive during the  windowTime  periods, and gets updated for each  windowTime .    Parameters  attribute :The attribute that should be checked for uniqueness. timestamp :The time considered as the current time for the window to act upon. The value of this parameter should be monotonically increasing. windowTime :The batch time period for which the window should hold events. startTime  (Optional): The user-defined start time. This can either be a constant (of the  int ,  long  or  time  type) or an attribute of the corresponding stream (of the long type). If an attribute is provided, the initial value of this attribute is considered as the  startTime . When the  startTime  is not given, the initial value of the timestamp is used by default. timeout  (Optional): The time duration to wait for the arrival of new event before flushing and giving output for events belonging to a specific batch. If the timeout is not provided, the system waits until an event from next batch arrives to flush the current batch. replaceTimestampWithBatchEndTime  (Optional): Replaces the value for the  timestamp  parameter with the corresponding batch end time stamp.    Return Type  Returns current and expired events.    Examples  uniqueExternalTimeBatch(ip, eventTime, 20)  processes unique events based on the  ip  attribute that arrives every 20 milliseconds from the   eventTime . uniqueExternalTimeBatch(ip, eventTimestamp, 2 min)  processes unique events based on the  ip  attribute that arrives every 2 minutes from the  eventTimestamp . uniqueExternalTimeBatch(ip, eventTimestamp, 2 sec, 0)  processes unique events based on the  ip  attribute that arrives every 2 seconds from the  eventTimestamp . It starts on 0th millisecond of an hour. uniqueExternalTimeBatch(ip, eventTimestamp, 2 sec, eventTimestamp, 100)  processes unique events based on the  ip  attribute that arrives every 2 seconds from the  eventTimestamp . It considers the  eventTimestamp  of the first event as the  startTime , and waits 100 milliseconds for the arrival of a new event before flushing current batch. uniqueExternalTimeBatch(ip, eventTimestamp, 2 sec, eventTimestamp, 100, true)  processes unique events based on the ip attribute that arrives every 2 seconds from the  eventTimestamp . It considers the  eventTimestamp  of the first event as  startTime , and waits 100 milliseconds for the arrival of a new event before flushing current batch. Here, the value for  eventTimestamp  is replaced with the timestamp of the batch end.", 
            "title": "uniqueExternalTimeBatch"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#output-event-categories", 
            "text": "The output of a window can be current events, expired events or both as specified. Following are the key words to be used to specify the event category that is emitted from a window.     Key Word  Outcome      current events  This emits all the events that arrive to the window. This is the default event category emitted when no particular category is specified.    expired events  This emits all the events that expire from the window.    all events  This emits att the events that arrive to the window as well as all the events that expire from the window.     Syntax  from  input_stream #window. window_name select *\ninsert  output_event_category  into  output_stream   Example \nThe following selects all the expired events of the  TempStream  input stream within a time window of 1 minute, and inserts them into the  DelayedTempStream  output stream.  from TempStream#window.time(1 min)select *\ninsert expired events into DelayedTempStream", 
            "title": "Output event categories"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#output-rate-limiting", 
            "text": "Output rate limiting allows queries to emit events periodically based on the condition specified.  Purpose  This allows you to limit the output to what is required in order to avoid viewing unnecessary information.  Syntax  The following is the syntax of an output rate limiting configuration.  from  input stream name ...select  attribute name ,  attribute name , ...\noutput ({ output-type } every ( time interval | event interval  events) | snapshot every  time interval )\ninsert into  output stream name   The parameters configured for the output rate limiting are described in the following table.     Parameter  Description      output-time  This specifies which event(s) should be emitted as the output of the query. The possible values are as follows: first : Only the first event processed by the query in the specified time interval/sliding window is emitted. last : Only the last event processed by the query in the specified time interval/sliding window is emitted. all : All the events processed by the query in the specified time interval/sliding window are emitted.    time interval  The time interval for the periodic event emission.    event interval  The number of events that defines the interval at which the emission of events take place. e.g., if the event interval is 10, the query emits a result for every 10 events.     Examples   Emitting events based on number of events Here the events are emitted every time the specified number of events arrive You can also specify whether to to emit only the first event, last event, or all events out of the events that arrived. \nIn this example, the last temperature per sensor is emitted for every 10 events.   from TempStreamselect temp\ngroup by deviceID\noutput last every 10 events\ninsert into LowRateTempStream;   Emitting events based on time\nHere, events are emitted for every predefined time interval. You can also specify whether to to emit only the first event, last event, or all events out of the events that arrived during the specified time interval.   from TempStreamoutput every 10 sec\ninsert into LowRateTempStream;   Emitting a periodic snapshot of events This method works best with windows. When an input stream is connected to a window, snapshot rate limiting emits all the current events that have arrived and do not have corresponding expired events for every predefined time interval. If the input stream is not connected to a window, only the last current event for each predefined time interval is emitted. \nThe following emits a snapshot of the events in a time window of 5 seconds every 1 second.    from TempStream#window.time(5 sec)output snapshot every 1 sec\ninsert into SnapshotTempStream;", 
            "title": "Output rate limiting"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#joins", 
            "text": "Join allows two event streams to be merged based on a condition. In order to carry out a join, each stream should be connected to a window. If no window is specified, a window of zero length ( #window.length(0) ) is assigned to the input event stream by default. During the joining process each incoming event on each stream is matched against all the events in the other input event stream window based on the given condition. An output event is generated for all the matching event pairs.  Syntax \nThe syntax for a join is as follows:  from  input stream name [ filter condition ]#window. window name ( parameter , ... ) {unidirectional} {as  reference }\n         join  input stream name #window. window name ( parameter ,  ... ) {unidirectional} {as  reference }\n    on  join condition \n    within  time gap \nselect  attribute name ,  attribute name , ...\ninsert into  output stream name   Example  define stream TempStream(deviceID long, roomNo int, temp double);\ndefine stream RegulatorStream(deviceID long, roomNo int, isOn bool);\n\nfrom TempStream[temp   30.0]#window.time(1 min) as T\n  join RegulatorStream[isOn == false]#window.length(1) as R\n  on T.roomNo == R.roomNo\nselect T.roomNo, R.deviceID, 'start' as action\ninsert into RegulatorActionStream;  WSO2 Siddhi currently supports the following types of joins.", 
            "title": "Joins"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#left-outer-join", 
            "text": "Outer join allows two event streams to be merged based on a condition. However, it returns all the events of left stream even if there are no matching events in the right stream. Here each stream should be associated with a window. During the joining process, each incoming event of each stream is matched against all the events in the other input event stream window based on the given condition. Incoming events of the right stream are matched against all events in the left event stream window based on the given condition. An output event is generated for all the matching event pairs. An output event is generated for incoming events of the left stream even if there are no matching events in right stream.  Example \nThe following query generates output events for all the events in the  stockStream  stream whether there is a match for the symbol in the  twitterStream  stream or not.  from stockStream#window.length(2) \nleft outer join twitterStream#window.length(1)\non stockStream.symbol== twitterStream.symbol\nselect stockStream.symbol as symbol, twitterStream.tweet, stockStream.price\ninsert all events into outputStream ;", 
            "title": "Left Outer Join"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#right-outer-join", 
            "text": "This is similar to left outer join. It returns all the events of the right stream even if there are no matching events in the left stream. Incoming events of the left stream are matched against all events in the right event stream window based on the given condition. An output event is generated for all the matching event pairs. An output event is generated for incoming events of the right stream even if there are no matching events in left stream.  Example \nThe following generates output events for all the events in the  twitterStream  stream whether there is a match for the symbol in the  stockStream  stream or not.  from stockStream#window.length(2) \nright outer join twitterStream#window.length(1)\non stockStream.symbol== twitterStream.symbol\nselect stockStream.symbol as symbol, twitterStream.tweet, stockStream.price\ninsert all events into outputStream ;", 
            "title": "Right Outer Join"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#full-outer-join", 
            "text": "", 
            "title": "Full Outer Join"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#patterns-and-sequences", 
            "text": "Patterns and sequences allow event streams to be correlated over time and detect event patterns based on the order of event arrival.", 
            "title": "Patterns and Sequences"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#patterns", 
            "text": "Pattern allows event streams to be correlated over time and detect event patterns based on the order of event arrival. With pattern there can be other events in between the events that match the pattern condition. It creates state machines to track the states of the matching process internally. Pattern can correlate events over multiple input streams or over the same input stream. Therefore, each matched input event need to be referenced so that that it can be accessed for future processing and output generation.  Syntax \nThe following is the syntax for a pattern configuration:  from {every}  input event reference = input stream name [ filter condition ] -  {every}  input event reference = input stream name [ filter condition ] -  ...        within  time gap \nselect  input event reference . attribute name ,  input event reference . attribute name , ...\ninsert into  output stream name   Example  The following query sends an alert if the temperature of a room increases by 5 degrees within 10 min.  from every( e1=TempStream ) -  e2=TempStream[e1.roomNo==roomNo and (e1.temp + 5)  = temp ]\n    within 10 min\nselect e1.roomNo, e1.temp as initialTemp, e2.temp as finalTemp\ninsert into AlertStream;  WSO2 Siddhi supports the following types of patterns:\n+ Counting patterns\n+ Logical patterns", 
            "title": "Patterns"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#counting-patterns", 
            "text": "Counting patterns allow multiple events that may or may not have been received in a sequential order based on the same matching condition.  Syntax  The number of events matched can be limited via postfixes as explained below.     Postfix  Description  Example       n1:n2  This matches  n1  to  n2  events.  1:4  matches 1 to 4 events.     n:  This matches  n  or more events.  2:  matches 2 or more events.     :n  This matches up to  n  events.  :5  matches up to 5 events.     n  This matches exactly  n  events.  5  matches exactly 5 events.      Specific occurrences of the events that should be matched based on count limits are specified via key words and numeric values within square brackets as explained with the examples given below.   e1[3]  refers to the 3rd event.  e1[last]  refers to the last event.  e1[last - 1]  refers to the event before the last event.   Example \nThe following query calculates the temperature difference between two regulator events.  define stream TempStream(deviceID long, roomNo int, temp double);\ndefine stream RegulatorStream(deviceID long, roomNo int, tempSet double, isOn bool);\n\nfrom every( e1=RegulatorStream) -  e2=TempStream[e1.roomNo==roomNo] 1:  -  e3=RegulatorStream[e1.roomNo==roomNo]\nselect e1.roomNo, e2[0].temp - e2[last].temp as tempDiff\ninsert into TempDiffStream;", 
            "title": "Counting Patterns"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#logical-patterns", 
            "text": "Logical pattern matches events that arrive in temporal order and correlates events with logical relationships.  Syntax  Keywords such as and and or can be used instead of -  to illustrate the logical relationship.     Key Word  Description      and  This allows two events received in any order to be matched.    or  One event from either event stream can be matched regardless of the order in which the events were received.     Example \nThe following query sends an alert when the room temperature reaches the temperature set on the regulator. The pattern matching is reset every time the temperature set on the regulator changes.  define stream TempStream(deviceID long, roomNo int, temp double);\ndefine stream RegulatorStream(deviceID long, roomNo int, tempSet double);\n\nfrom every( e1=RegulatorStream ) -  e2=TempStream[e1.roomNo==roomNo and e1.tempSet  = temp ] or e3=RegulatorStream[e1.roomNo==roomNo]\nselect e1.roomNo, e2.temp as roomTemp\nhaving e3 is null\ninsert into AlertStream;", 
            "title": "Logical Patterns"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#sequences", 
            "text": "Sequence allows event streams to be correlated over time and detect event sequences based on the order of event arrival. With sequence there cannot be other events in between the events that match the sequence condition. It creates state machines to track the states of the matching process internally. Sequence can correlate events over multiple input streams or over the same input stream. Therefore, each matched input event needs to be referenced so that it can be accessed for future processing and output generation. Syntax  The following is the syntax for a sequence configuration.  from {every}  input event reference = input stream name [ filter condition ],  input event reference = input stream name [ filter condition ]{+|*|?}, ...       within  time gap \nselect  input event reference . attribute name ,  input event reference . attribute name , ...\ninsert into  output stream name   Example  The following query sends an alert if there is more than 1 degree increase in the temperature between two consecutive temperature events.  WSO2 Siddhi supports the following types of sequences:   Counting sequences  Logical sequences", 
            "title": "Sequences"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#counting-sequences", 
            "text": "Counting sequence allows us to match multiple consecutive events based on the same matching condition.  Syntax  The number of events matched can be limited via postfixes as explained below.     Postfix  Description      *  This matches zero or more events.    +  This matches 1 or more events.    ?  This matches zero events or one event.     Example  The following query identifies peak temperatures.  define stream TempStream(deviceID long, roomNo int, temp double);\ndefine stream RegulatorStream(deviceID long, roomNo int, tempSet double, isOn bool);\n\nfrom every e1=TempStream, e2=TempStream[e1.temp  = temp]+, e3=TempStream[e2[last].temp   temp]\nselect e1.temp as initialTemp, e2[last].temp as peakTemp\ninsert into TempDiffStream;", 
            "title": "Counting sequences"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#logical-sequences", 
            "text": "Logical sequence matches events that arrive in temporal order and correlates events with logical relationships.  Syntax  Keywords such as and and or can be used instead of -  to illustrate the logical relationship.     Keyword  Description      and  This allows two events received in any order to be matched.    or  One event from either event stream can be matched regardless of the order in which the events were received.     Example  The following query creates a notification when a regulator event is followed by both temperature and humidity events.  define stream TempStream(deviceID long, temp double);define stream HumidStream(deviceID long, humid double);\ndefine stream RegulatorStream(deviceID long, isOn bool);\n\nfrom every e1=RegulatorStream, e2=TempStream and e3=HumidStream\nselect e2.temp, e3.humid\ninsert into StateNotificationStream;", 
            "title": "Logical Sequences"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#partitions", 
            "text": "Partitions allow events and queries to be divided in order to process them in parallel and in isolation. Each partition is tagged with a partition key. Only events corresponding to this key are processed for each partition. A partition can contain one or more Siddhi queries.\nSiddhi supports both variable partitions and well as range partitions.", 
            "title": "Partitions"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#variable-partitions", 
            "text": "A variable partition is created by defining the partition key using the categorical (string) attribute of the input event stream.  Syntax  partition with (  attribute name  of  stream name ,  attribute name  of  stream name , ... )begin\n     query \n     query \n    ...\nend;  Example  The following query calculates the maximum temperature recorded for the last 10 events emitted per sensor.  partition with ( deviceID of TempStream )begin\n    from TempStream#window.length(10)\n    select roomNo, deviceID, max(temp) as maxTemp\n    insert into DeviceTempStream\nend;", 
            "title": "Variable Partitions"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#range-partitions", 
            "text": "A range partition is created by defining the partition key using the numerical attribute of the input event stream.  Syntax  partition with (  condition  as  partition key  or  condition  as  partition key  or ... of  stream name , ... )begin\n     query \n     query \n    ...\nend;  Example  The following query calculates the average temperature for the last 10 minutes per office area.  partition with ( roomNo =1030 as 'serverRoom' or roomNo 1030 and roomNo =330 as 'officeRoom' or roomNo 330 as 'lobby' of TempStream) )begin\n    from TempStream#window.time(10 min)\n    select roomNo, deviceID, avg(temp) as avgTemp\n    insert into AreaTempStream\nend;", 
            "title": "Range Partitions"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#event-table", 
            "text": "An event table is a stored version of an event stream or a table of events. It allows Siddhi to work with stored events. Events are stored in-memory by default, and Siddhi also provides an extension to work with data/events stored in RDBMS data stores.", 
            "title": "Event Table"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#defining-an-event-table", 
            "text": "An event table definition defines the table schema. The syntax for an event table definition is as follows.  define table  table name  ( attribute name   attribute type ,  attribute name   attribute type , ... );  Example  The following creates a table named  RoomTypeTable  with the attributes  roomNo  (an  INT  attribute) and  type  (a  STRING  attribute).  define table RoomTypeTable (roomNo int, type string);", 
            "title": "Defining An Event Table"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#event-table-types", 
            "text": "Siddhi supports the following types of event tables.", 
            "title": "Event Table Types"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#in-memory-event-table", 
            "text": "In memory event tables are created to store events for later access. Event tables can be configured with primary keys to avoid the duplication of data, and indexes for fast event access.\nPrimary keys are configured by including the  @PrimaryKey  annotation within the event table configuration. Each event table can have only one attribute defined as the primary key, and the value for this attribute should be unique for each entry saved in the table. This ensures that entries in the table are not duplicated\nIndexes are configured by including the  @Index  annotation within the event table configuration. Each event table configuration can have only one  @Index  annotation. However, multiple attributes can be specified as index attributes via a single annotation. When the  @Index  annotation is defined, multiple entries can be stored for a given key in the table. Indexes can be configured together with primary keys.   Examples   Configuring primary keys\nThe following query creates an event table with the  symbol  attribute defined as the primary key. Therefore, each entry in this table should have a unique value for the  symbol  attribute.   @PrimaryKey('symbol')\ndefine table StockTable (symbol string, price float, volume long);   Configuring indexes   The following query creates an indexed event table named  RoomTypeTable  with the attributes  roomNo  (as an  INT  attribute) and  type  (as a  STRIN G attribute). All entries in the table are to be indexed by the  roomNo  attribute.  @Index('roomNo')\ndefine table RoomTypeTable (roomNo int, type string);", 
            "title": "In-memory Event Table"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#hazlecast-event-table", 
            "text": "Event tables allow event data to be persisted in a distributed manner using Hazelcast in-memory data grids. This functionality is enabled using the  From  annotation. Also, the connection instructions for the Hazelcast cluster can be provided with the  From  annotation.\nThe following is a list of connection instructions that can be provided with the  From  annotation.   cluster.name : Hazelcast cluster/group name [Optional]  (i.e cluster.name='cluster_a')  cluster.password : Hazelcast cluster/group password [Optional]  (i.e cluster.password='pass@cluster_a')  cluster.addresses : Hazelcast cluster addresses (ip:port) as a comma separated string [Optional, client mode only] (i.e cluster.addresses='192.168.1.1:5700,192.168.1.2:5700')  well.known.addresses : Hazelcast WKAs (ip) as a comma separated string [Optional, server mode only] (i.e well.known.addresses='192.168.1.1,192.168.1.2')  collection.name : Hazelcast collection object name [Optional, can be used to share single table between multiple EPs] (i.e collection.name='stockTable')   Examples   Creating a table backed by a new Hazelcast instance   The following query creates an event table named  RoomTypeTable  with the attributes  roomNo  (an  INT  attribute) and  type  (a  STRING  attribute), backed by a  new  Hazelcast Instance.  @from(eventtable = 'hazelcast')\ndefine table RoomTypeTable(roomNo int, type string);   Creating a table backed by a new Hazelcast instance in a new Hazelcast cluster\nThe following query creates an event table named  RoomTypeTable  with the attributes  roomNo  (an  INT  attribute) and  type  (a  STRING  attribute), backed by a  new  Hazelcast Instance in a new Hazelcast cluster.   @from(eventtable = 'hazelcast', cluster.name = 'cluster_a', cluster.password = 'pass@cluster_a')\ndefine table RoomTypeTable(roomNo int, type string);   Creating a table backed by an existing Hazelcast instance in an existing Hazelcast cluster\nThe following query creates an event table named  RoomTypeTable  with the attributes  roomNo  (an  INT  attribute) and  type  (a  STRING  attribute), backed by an existing Hazelcast Instance in an existing Hazelcast Cluster.   @from(eventtable = 'hazelcast', cluster.name = 'cluster_a', cluster.password = 'pass@cluster_a', cluster.addresses='192.168.1.1:5700,192.168.1.2.5700')\ndefine table RoomTypeTable(roomNo int, type string);", 
            "title": "Hazlecast Event Table"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#rdbms-event-table", 
            "text": "An event table can be backed with an RDBMS event store using the  From  annotation. You can also provide the connection instructions to the event table with this annotation. The RDBMS table name can be different from the event table name defined in Siddhi, and Siddhi always refers to the defined event table name. However the defined event table name cannot be same as an already existing stream name because syntactically, both are considered the same in the Siddhi Query Language.  *The RDBMS event table has been tested with the following databases:   MySQL  H2  Oracle*   Example   Creating an event table backed by an RDBMS table   The following query creates an event table named  RoomTypeTable  with the attributes  roomNo  (an  INT  attribute) and  type  (a  STRING  attribute), backed by an RDBMS table named  RoomTable  from the data source named  AnalyticsDataSource .  @From(eventtable='rdbms', datasource.name='AnalyticsDataSource', table.name='RoomTable')\ndefine table RoomTypeTable (roomNo int, type string);  The datasource.name given here is injected to the Siddhi engine by the CEP/DAS server. To configure data sources in the CEP/DAS, see WSO2 Administration Guide - Configuring an RDBMS Datasource.\n+ Creating an event table backed by a MySQL table\nThe following query creates an event table named RoomTypeTable with the attributes roomNo (an INT attribute) and type (a STRING attribute), backed by a MySQL table named  RoomTable  from the  cepdb  database located at  localhost:3306  with  root  as both the username and the password.", 
            "title": "RDBMS Event Table"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#caching-events", 
            "text": "Several caches can be used with RDBMS backed event tables in order to reduce I/O operations and improve their performance. Currently all cache implementations provide size-based algorithms.  The following elements are added with the Fromannotation to add caches.    cache : This specifies the cache implementation to be added. The supported cache implementations are as follows.    Basic : Events are cached in a First-In-First-Out manner where the oldest event is dropped when the cache is full.    LRU  (Least Recently Used): The least recently used event is dropped when the cache is full.    LFU  (Least Frequently Used): The least frequently used event is dropped when the cache is full.    If the  cache  element is not specified, the basic cache is added by default.    cache.size : This defines the size of the cache. If this element is not added, the default cache size of 4096 is added by default.    Example  The following query creates an event table named  RoomTypeTable  with the attributes  roomNo  (an  INT  attribute) and  type  (a  STRING  attribute), backed by an RDBMS table using the LRU algorithm for caching 3000 events.  @From(eventtable='rdbms', datasource.name='AnalyticsDataSource', table.name='RoomTable', cache='LRU', cache.size='3000')define table RoomTypeTable (roomNo int, type string);", 
            "title": "Caching Events"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#using-bloom-filters", 
            "text": "A Bloom Filter is an algorithm or an approach that can be used to perform quick searches. If you apply a Bloom Filter to a data set and carry out an  isAvailablecheck  on that specific Bloom Filter instance, an accurate answer is returned if the search item is not available. This allows the quick improvement of updates, joins and  isAvailable  checks.  Example  The following example shows how to include Bloom filters in an event table update query.  define stream StockStream (symbol string, price float, volume long);define stream CheckStockStream (symbol string, volume long);\n@from(eventtable = 'rdbms' ,datasource.name = 'cepDB' , table.name = 'stockInfo' , bloom.filters = 'enable')\ndefine table StockTable (symbol string, price float, volume long);\n\n@info(name = 'query1')\nfrom StockStream\ninsert into StockTable ;\n\n@info(name = 'query2')\nfrom CheckStockStream[(StockTable.symbol==symbol) in StockTable]\ninsert into OutStream;", 
            "title": "Using Bloom filters"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#supported-event-table-operators", 
            "text": "The following event table operators are supported for Siddhi.", 
            "title": "Supported Event Table Operators"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#insert-into", 
            "text": "Syntax  from  input stream name  \nselect  attribute name ,  attribute name , ...\ninsert into  table name   To insert only the specified output event category, use the  current events ,  expired events  or the  all events  keyword between  insert  and  into  keywords. For more information, see Output Event Categories.  Purpose  To store filtered events in a specific event table.  Parameters    input stream name : The input stream from which the events are taken to be stored in the event table.    attribute name : Attributes of the chosen events that are selected to be saved in the event table.    table name : The name of the event table in which the events should be saved.    Example  The following query inserts all the temperature events from the  TempStream  event stream to the  TempTable  event table.  from TempStream\nselect *\ninsert into TempTable;", 
            "title": "Insert into"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#delete", 
            "text": "Syntax  from  input stream name  \nselect  attribute name ,  attribute name , ...\ndelete  table name \n    on  condition   The  condition  element specifies the basis on which events are selected to be deleted. When specifying this condition, the attribute names should be referred to with the table name.\nTo delete only the specified output category, use the  current events ,  expired events  or the  all events  keyword. For more information, see Output Event Categories.  Purpose  To delete selected events that are stored in a specific event table.  Parameters    input stream name : The input stream that is the source of the events stored in the event table.    attribute name : Attributes to which the given condition is applied in order to filter the events to be deleted.    table name : The name of the event table from which the filtered events are deleted.    condition : The condition based on which the events to be deleted are selected.    Example  The following query deletes all the entries in the  RoomTypeTable  event table that have a room number that matches the room number in any event in the  DeleteStream  event stream.  define table RoomTypeTable (roomNo int, type string);\ndefine stream DeleteStream (roomNumber int);\n\nfrom DeleteStream\ndelete RoomTypeTable\n    on RoomTypeTable.roomNo == roomNumber;", 
            "title": "Delete"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#update", 
            "text": "Syntax  from  input stream name  \nselect  attribute name  as  table attribute name ,  attribute name  as  table attribute name , ...\nupdate  table name \n    on  condition   The  condition  element specifies the basis on which events are selected to be updated. When specifying this condition, the attribute names should be referred to with the table name.\nTo update only the specified output category, use the  current events ,  expired events  or the  all events  keyword. For more information, see Output Event Categories.  Purpose  To update selected events in an event table.  Parameters    input stream name : The input stream that is the source of the events stored in the event table.    attribute name : Attributes to which the given  condition  is applied in order to filter the events to be updated.    table name : The name of the event table in which the filtered events should be updated.    condition : The condition based on which the events to be updated are selected.    Example  The following query updates room type of all the events in the  RoomTypeTable  event table that have a room number that matches the room number in any event in the  UpdateStream  event stream.  define table RoomTypeTable (roomNo int, type string);\ndefine stream UpdateStream (roomNumber int, roomType string);\n\nfrom UpdateStream\nselect roomType as type\nupdate RoomTypeTable\n    on RoomTypeTable.roomNo == roomNumber;", 
            "title": "Update"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#insert-overwrite", 
            "text": "Syntax  from  input stream name  \nselect  attribute name  as  table attribute name ,  attribute name  as  table attribute name , ...\ninsert overwrite  table name \n    on  condition   The  condition  element specifies the basis on which events are selected to be inserted or overwritten. When specifying this condition, the attribute names should be referred to with the table name.\nWhen specifying the  table attribute  name, the attributes should be specified with the same name specified in the event table, allowing Siddhi to identify the attributes that need to be updated/inserted in the event table.  Purpose  Parameters    input stream name : The input stream that is the source of the events stored in the event table.    attribute name : Attributes to which the given  condition  is applied in order to filter the events to be inserted or over-written.    table name : The name of the event table in which the filtered events should be inserted or over-written.    condition  : The condition based on which the events to be inserted or over-written are selected.    Example \nThe following query searches for events in the  UpdateTable  event table that have room numbers that match the same in the  UpdateStream  stream. When such events are founding the event table, they are updated. When a room number available in the stream is not found in the event table, it is inserted from the stream.\n ```sql\n define table RoomTypeTable (roomNo int, type string);\n define stream UpdateStream (roomNumber int, roomType string);  from UpdateStream\n select roomNumber as roomNo, roomType as type\n insert overwrite RoomTypeTable\n     on RoomTypeTable.roomNo == roomNo;\n ```", 
            "title": "Insert Overwrite"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#in", 
            "text": "Syntax  condition  in  table name   The  condition  element specifies the basis on which events are selected to be inserted or overwritten. When specifying this condition, the attribute names should be referred to with the table name.  Purpose  Parameters  Example  define table ServerRoomTable (roomNo int);\ndefine stream TempStream (deviceID long, roomNo int, temp double);\n\nfrom TempStream[ServerRoomTable.roomNo == roomNo in ServerRoomTable]\ninsert into ServerTempStream;", 
            "title": "In"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#join", 
            "text": "Syntax  from  input stream name #window.length(1) join  table_name \n    on  input stream name . attribute name   condition   table_name . table attribute name \nselect  input stream name . attribute name ,  table_name . table attribute name , ...\ninsert into  output stream name   At the time of joining, the event table should not be associated with window operations because an event table is not an active construct. Two event tables cannot be joined with each other due to the same reason.  Purpose \nTo allow a stream to retrieve information from an event table.  Parameters  Example  The following query performs a join to update the room number of the events in the  TempStream  stream with that of the corresponding events in the  RoomTypeTable  event table, and then inserts the updated events into the  EnhancedTempStream  stream.  define table RoomTypeTable (roomNo int, type string);\ndefine stream TempStream (deviceID long, roomNo int, temp double);\n\nfrom TempStream join RoomTypeTable\n    on RoomTypeTable.roomNo == TempStream.roomNo\nselect deviceID, RoomTypeTable.roomNo as roomNo, type, temp\ninsert into EnhancedTempStream;", 
            "title": "Join"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#event-window", 
            "text": "An event window is a window that can be shared across multiple queries. Events are inserted from one or more streams. The event window publishes current and/or expired events as the output. The time at which these events are published depends on the window type.  Syntax  The following is the syntax for an event window.  define window  event window name  ( attribute name   attribute type ,  attribute name   attribute type , ... )  window type ( parameter ,  parameter , \u2026)  output event type ;  Examples   Returning all output categories   In the following query, the window type is not specified in the window definition. Therefore, it emits both current and expired events as the output.  define window SensorWindow (name string, value float, roomNo int, deviceID string) timeBatch(1 second);   Returning a specified output category   In the following query, the window type is  output all events . Therefore, it emits both current and expired events as the output.  define window SensorWindow (name string, value float, roomNo int, deviceID string) timeBatch(1 second) output all events;", 
            "title": "Event Window"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#supported-event-window-operators", 
            "text": "The following operators are supported for event windows.", 
            "title": "Supported Event Window Operators"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#insert-into_1", 
            "text": "Syntax  from  input stream name  \nselect  attribute name ,  attribute name , ...\ninsert into  window name   To insert only the specified output event category, use the  current events ,  expired events  or the  all events  keyword between  insert  and  into  keywords. For more information, see Output Event Categories.  Purpose  To insert events from an event stream to a window.  Parameters    input stream name :  The event stream from which events are inserted into the event window.    attribute name : The name of the attributes with which the events are inserted from the event stream to the event window. Multiple attributes can be specified as a comma separated list.    window name : The event window to which events are inserted from the event stream.    Example  The following query inserts both current and expired events from an event stream named  sensorStream  to an event window named  sensorWindow .  from SensorStream\ninsert into SensorWindow;", 
            "title": "Insert Into"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#output", 
            "text": "An event window can be used as a stream in any query. However, an ordinary window cannot be applied to the output of an event window.  Syntax  from  window name  \nselect  attribute name ,  attribute name , ...\ninsert into  event stream name   Purpose  To inject the output of an event window into an event stream.  Parameters    window name : The event window of which the output is injected into the specified stream.    attribute name : The name of the attributes with which the events are inserted from the event stream to the event window. Multiple attributes can be specified as a comma separated list.    event stream name : The event stream to which the output of the specified event window is injected.    Example \nThe following query selects the name and the maximum values for the  value  and  roomNo  attributes from an event window named  SensorWindow , and inserts them into an event stream named  MaxSensorReadingStream .  from SensorWindow\nselect name, max(value) as maxValue, roomNo\ninsert into MaxSensorReadingStream;", 
            "title": "Output"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#join_1", 
            "text": "Example   define stream TempStream(deviceID long, roomNo int, temp double);\n define stream RegulatorStream(deviceID long, roomNo int, isOn bool);\n define window TempWindow(deviceID long, roomNo int, temp double) time(1 min);\n\n from TempStream[temp   30.0]\n insert into TempWindow;\n\n from TempWindow\n join RegulatorStream[isOn == false]#window.length(1) as R\n on TempWindow.roomNo == R.roomNo\n select TempWindow.roomNo, R.deviceID, 'start' as action\n insert into RegulatorActionStream;", 
            "title": "Join"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#event-trigger", 
            "text": "Event triggers allow events to be created periodically based on a specified time interval.  Syntax  The following is the syntax for an event trigger definition.  define trigger  trigger name  at {'start'| every  time interval | ' cron expression '};  Examples   Triggering events regularly at specific time intervals   The following query triggers events every 5 minutes.   define trigger FiveMinTriggerStream at every 5 min;   Triggering events at a specific time on specified days\nThe following query triggers an event at 10.15 AM every Monday, Tuesday, Wednesday, Thursday and Friday.    define trigger FiveMinTriggerStream at '0 15 10 ? * MON-FRI';", 
            "title": "Event Trigger"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#siddhi-logger", 
            "text": "The Siddhi Logger logs events that arrive in different logger priorities such as  INFO ,  DEBUG ,  WARN ,  FATAL ,  ERROR ,  OFF , and  TRACE .  Syntax  The following is the syntax for a query with a Siddhi logger.  void  log( string  priority,  string  logMessage,  bool  isEventLogged)  The parameters configured are as follows.    prioroty : The logging priority. Possible values are  INFO ,  DEBUG ,  WARN ,  FATAL ,  ERROR ,  OFF , and  TRACE . If no value is specified for this parameter,  INFO  is printed as the priority by default.    logMessage : This parameter allows you to specify a message to be printed in the log.    isEventLogged : This parameter specifies whether the event body should be included in the log. Possible values are  true  and  false . If no value is specified, the event body is not printed in the log by default.    Examples   The following query logs the event with the  INFO  logging priority. This is because the priority is not specified.   from StockStream#log()\nselect *\ninsert into OutStream;   The following query logs the event with the  INFO  logging priority (because the priority is not specified) and the  test message  text.   from StockStream#log('test message')\nselect *\ninsert into OutStream;   The following query logs the event with the  INFO  logging priority because a priority is not specified. The event itself is printed in the log.   from StockStream#log(true)\nselect *\ninsert into OutStream;   The following query logs the event with the  INFO  logging priority (because the priority is not specified) and the  test message  text. The event itself is printed in the log.   from StockStream#log('test message', true)\nselect *\ninsert into OutStream;   The following query logs the event with the  WARN  logging priority and the  test message  text.   from StockStream#log('warn','test message')\nselect *\ninsert into OutStream;   The following query logs the event with the  WARN  logging priority and the  test message  text.  The event itself is printed in the log.   from StockStream#log('warn','test message',true)\nselect *\ninsert into OutStream;", 
            "title": "Siddhi Logger"
        }, 
        {
            "location": "/documentation/siddhi-4.0/#eval-script", 
            "text": "Eval script allows Siddhi to process events using other programming languages by including their functions in the Siddhi queries. Eval script functions can be defined like event tables or streams and referred in the queries as Inbuilt Functions of Siddhi.  Syntax  The following is the syntax for a Siddhi query with an Eval Script definition.  define function  function name [ language name ] return  return type  {\n     operation of the function \n};  The following parameters are configured when defining an eval script.    function name :  The name of the function from another programming language that should be included in the Siddhi query.    language name : The name of the other programming language from which the function included in the Siddhi query is taken. The languages supported are JavaScript, R and Scala.    return type : The return type of the function defined. The return type can be  int ,  long ,  float ,  double ,  string ,  bool  or  object . Here the function implementer should be responsible for returning the output on the defined return type for proper functionality.     operation of the function : Here, the execution logic of the defined logos should be added. This logic should be written in the language specified in the  language name  parameter, and the return should be of the type specified in the  return type  parameter.    Examples   Concatenating a JavaScript function   The following query performs the concatenating function of the JavaScript language and returns the output as a string.  define function concatFn[JavaScript] return string {\n    var str1 = data[0];\n    var str2 = data[1];\n    var str3 = data[2];\n    var responce = str1 + str2 + str3;\n    return responce;\n};\n\ndefine stream TempStream(deviceID long, roomNo int, temp double);\n\nfrom TempStream\nselect concatFn(roomNo,'-',deviceID) as id, temp \ninsert into DeviceTempStream;   Concatenating an R function   The following query performs the concatenating function of the R language and returns the output as a string.  define function concatFn[R] return string {\n    return(paste(data, collapse= ));\n};\n\ndefine stream TempStream(deviceID long, roomNo int, temp double);\n\nfrom TempStream\nselect concatFn(roomNo,'-',deviceID) as id, temp\ninsert into DeviceTempStream;   Concatenating a Scala function   The following query performs the concatenating function of the Scala language and returns the output as a string.  define function concatFn[Scala] return string {\n    var concatenatedString =\n     for(i  - 0 until data.length){\n         concatenatedString += data(i).toString\n     }\n     concatenatedString\n};\n\ndefine stream TempStream(deviceID long, roomNo int, temp double);\n\nfrom TempStream\nselect concatFn(roomNo,'-',deviceID) as id, temp\ninsert into DeviceTempStream;", 
            "title": "Eval Script"
        }, 
        {
            "location": "/extensions/", 
            "text": "Siddhi Extensions\n\n\nWIP \n\n\nhttps://github.com/wso2-extensions/?utf8=%E2%9C%93\nq=siddhi\ntype=\nlanguage=", 
            "title": "Extensions"
        }, 
        {
            "location": "/extensions/#siddhi-extensions", 
            "text": "WIP   https://github.com/wso2-extensions/?utf8=%E2%9C%93 q=siddhi type= language=", 
            "title": "Siddhi Extensions"
        }, 
        {
            "location": "/about/license/", 
            "text": "Copyright (c) 2017 WSO2 Inc. (\nhttp://www.wso2.org\n) All Rights Reserved.\n\n\nWSO2 Inc. licenses this file to you under the Apache License,\nVersion 2.0 (the \"License\"); you may not use this file except\nin compliance with the License.\nYou may obtain a copy of the License at\n\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\n\nUnless required by applicable law or agreed to in writing,\nsoftware distributed under the License is distributed on an\n\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, either express or implied.  See the License for the\nspecific language governing permissions and limitations\nunder the License.\n\n\n-------------------------------------------------------------------------\n                              Apache License\n                        Version 2.0, January 2004\n                     http://www.apache.org/licenses/\n\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n1. Definitions.\n\n   \nLicense\n shall mean the terms and conditions for use, reproduction,\n   and distribution as defined by Sections 1 through 9 of this document.\n\n   \nLicensor\n shall mean the copyright owner or entity authorized by\n   the copyright owner that is granting the License.\n\n   \nLegal Entity\n shall mean the union of the acting entity and all\n   other entities that control, are controlled by, or are under common\n   control with that entity. For the purposes of this definition,\n   \ncontrol\n means (i) the power, direct or indirect, to cause the\n   direction or management of such entity, whether by contract or\n   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n   outstanding shares, or (iii) beneficial ownership of such entity.\n\n   \nYou\n (or \nYour\n) shall mean an individual or Legal Entity\n   exercising permissions granted by this License.\n\n   \nSource\n form shall mean the preferred form for making modifications,\n   including but not limited to software source code, documentation\n   source, and configuration files.\n\n   \nObject\n form shall mean any form resulting from mechanical\n   transformation or translation of a Source form, including but\n   not limited to compiled object code, generated documentation,\n   and conversions to other media types.\n\n   \nWork\n shall mean the work of authorship, whether in Source or\n   Object form, made available under the License, as indicated by a\n   copyright notice that is included in or attached to the work\n   (an example is provided in the Appendix below).\n\n   \nDerivative Works\n shall mean any work, whether in Source or Object\n   form, that is based on (or derived from) the Work and for which the\n   editorial revisions, annotations, elaborations, or other modifications\n   represent, as a whole, an original work of authorship. For the purposes\n   of this License, Derivative Works shall not include works that remain\n   separable from, or merely link (or bind by name) to the interfaces of,\n   the Work and Derivative Works thereof.\n\n   \nContribution\n shall mean any work of authorship, including\n   the original version of the Work and any modifications or additions\n   to that Work or Derivative Works thereof, that is intentionally\n   submitted to Licensor for inclusion in the Work by the copyright owner\n   or by an individual or Legal Entity authorized to submit on behalf of\n   the copyright owner. For the purposes of this definition, \nsubmitted\n\n   means any form of electronic, verbal, or written communication sent\n   to the Licensor or its representatives, including but not limited to\n   communication on electronic mailing lists, source code control systems,\n   and issue tracking systems that are managed by, or on behalf of, the\n   Licensor for the purpose of discussing and improving the Work, but\n   excluding communication that is conspicuously marked or otherwise\n   designated in writing by the copyright owner as \nNot a Contribution.\n\n\n   \nContributor\n shall mean Licensor and any individual or Legal Entity\n   on behalf of whom a Contribution has been received by Licensor and\n   subsequently incorporated within the Work.\n\n2. Grant of Copyright License. Subject to the terms and conditions of\n   this License, each Contributor hereby grants to You a perpetual,\n   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n   copyright license to reproduce, prepare Derivative Works of,\n   publicly display, publicly perform, sublicense, and distribute the\n   Work and such Derivative Works in Source or Object form.\n\n3. Grant of Patent License. Subject to the terms and conditions of\n   this License, each Contributor hereby grants to You a perpetual,\n   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n   (except as stated in this section) patent license to make, have made,\n   use, offer to sell, sell, import, and otherwise transfer the Work,\n   where such license applies only to those patent claims licensable\n   by such Contributor that are necessarily infringed by their\n   Contribution(s) alone or by combination of their Contribution(s)\n   with the Work to which such Contribution(s) was submitted. If You\n   institute patent litigation against any entity (including a\n   cross-claim or counterclaim in a lawsuit) alleging that the Work\n   or a Contribution incorporated within the Work constitutes direct\n   or contributory patent infringement, then any patent licenses\n   granted to You under this License for that Work shall terminate\n   as of the date such litigation is filed.\n\n4. Redistribution. You may reproduce and distribute copies of the\n   Work or Derivative Works thereof in any medium, with or without\n   modifications, and in Source or Object form, provided that You\n   meet the following conditions:\n\n   (a) You must give any other recipients of the Work or\n       Derivative Works a copy of this License; and\n\n   (b) You must cause any modified files to carry prominent notices\n       stating that You changed the files; and\n\n   (c) You must retain, in the Source form of any Derivative Works\n       that You distribute, all copyright, patent, trademark, and\n       attribution notices from the Source form of the Work,\n       excluding those notices that do not pertain to any part of\n       the Derivative Works; and\n\n   (d) If the Work includes a \nNOTICE\n text file as part of its\n       distribution, then any Derivative Works that You distribute must\n       include a readable copy of the attribution notices contained\n       within such NOTICE file, excluding those notices that do not\n       pertain to any part of the Derivative Works, in at least one\n       of the following places: within a NOTICE text file distributed\n       as part of the Derivative Works; within the Source form or\n       documentation, if provided along with the Derivative Works; or,\n       within a display generated by the Derivative Works, if and\n       wherever such third-party notices normally appear. The contents\n       of the NOTICE file are for informational purposes only and\n       do not modify the License. You may add Your own attribution\n       notices within Derivative Works that You distribute, alongside\n       or as an addendum to the NOTICE text from the Work, provided\n       that such additional attribution notices cannot be construed\n       as modifying the License.\n\n   You may add Your own copyright statement to Your modifications and\n   may provide additional or different license terms and conditions\n   for use, reproduction, or distribution of Your modifications, or\n   for any such Derivative Works as a whole, provided Your use,\n   reproduction, and distribution of the Work otherwise complies with\n   the conditions stated in this License.\n\n5. Submission of Contributions. Unless You explicitly state otherwise,\n   any Contribution intentionally submitted for inclusion in the Work\n   by You to the Licensor shall be under the terms and conditions of\n   this License, without any additional terms or conditions.\n   Notwithstanding the above, nothing herein shall supersede or modify\n   the terms of any separate license agreement you may have executed\n   with Licensor regarding such Contributions.\n\n6. Trademarks. This License does not grant permission to use the trade\n   names, trademarks, service marks, or product names of the Licensor,\n   except as required for reasonable and customary use in describing the\n   origin of the Work and reproducing the content of the NOTICE file.\n\n7. Disclaimer of Warranty. Unless required by applicable law or\n   agreed to in writing, Licensor provides the Work (and each\n   Contributor provides its Contributions) on an \nAS IS\n BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n   implied, including, without limitation, any warranties or conditions\n   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n   PARTICULAR PURPOSE. You are solely responsible for determining the\n   appropriateness of using or redistributing the Work and assume any\n   risks associated with Your exercise of permissions under this License.\n\n8. Limitation of Liability. In no event and under no legal theory,\n   whether in tort (including negligence), contract, or otherwise,\n   unless required by applicable law (such as deliberate and grossly\n   negligent acts) or agreed to in writing, shall any Contributor be\n   liable to You for damages, including any direct, indirect, special,\n   incidental, or consequential damages of any character arising as a\n   result of this License or out of the use or inability to use the\n   Work (including but not limited to damages for loss of goodwill,\n   work stoppage, computer failure or malfunction, or any and all\n   other commercial damages or losses), even if such Contributor\n   has been advised of the possibility of such damages.\n\n9. Accepting Warranty or Additional Liability. While redistributing\n   the Work or Derivative Works thereof, You may choose to offer,\n   and charge a fee for, acceptance of support, warranty, indemnity,\n   or other liability obligations and/or rights consistent with this\n   License. However, in accepting such obligations, You may act only\n   on Your own behalf and on Your sole responsibility, not on behalf\n   of any other Contributor, and only if You agree to indemnify,\n   defend, and hold each Contributor harmless for any liability\n   incurred by, or claims asserted against, such Contributor by reason\n   of your accepting any such warranty or additional liability.\n\nEND OF TERMS AND CONDITIONS", 
            "title": "License"
        }
    ]
}